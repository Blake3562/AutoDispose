{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"AutoDispose \u00b6 AutoDispose is an RxJava 2+ tool for automatically binding the execution of RxJava streams to a provided scope via disposal/cancellation. Overview \u00b6 Often (especially in mobile applications), Rx subscriptions need to stop in response to some event (for instance, when Activity#onStop() executes in an Android app). In order to support this common scenario in RxJava 2, we built AutoDispose. The idea is simple: construct your chain like any other, and then at subscription you simply drop in the relevant factory call + method for that type as a converter. In everyday use, it usually looks like this: myObservable . doStuff () . as ( autoDisposable ( this )) // The magic . subscribe ( s -> ...); By doing this, you will automatically unsubscribe from myObservable as indicated by your scope - this helps prevent many classes of errors when an observable emits an item, but the actions taken in the subscription are no longer valid. For instance, if a network request comes back after a UI has already been torn down, the UI can\u2019t be updated - this pattern prevents this type of bug. autoDisposable() \u00b6 The main entry point is via static factory autoDisposable() methods in the AutoDispose class. There are two overloads: Completable and ScopeProvider . They return an AutoDisposeConverter object that implements all the RxJava Converter interfaces for use with the as() operator in RxJava types. Completable (as a scope) \u00b6 The Completable semantic is modeled after the takeUntil() operator, which accepts an Observable whose first emission is used as a notification to signal completion. This is logically the behavior of a Single , so we choose to make that explicit. Since the type doesn\u2019t matter, we simplify this further to just be a Completable , where the scope-end emission is just a completion event. All scopes in AutoDispose eventually resolve to a Completable that emits the end-of-scope notification in onComplete . onError will pass through to the underlying subscription. ScopeProvider \u00b6 public interface ScopeProvider { CompletableSource requestScope () throws Exception ; } ScopeProvider is an abstraction that allows objects to expose and control and provide their own scopes. This is particularly useful for objects with simple scopes (\u201cstop when I stop\u201d) or very custom state that requires custom handling. Note that Exceptions can be thrown in this, and will be routed through onError() . If the thrown exception is an instance of OutsideScopeException , it will be routed through any OutsideScopeHandler s (more below) first, and sent through onError() if not handled. AutoDisposePlugins \u00b6 Modeled after RxJava\u2019s plugins, this allows you to customize the behavior of AutoDispose. OutsideScopeHandler \u00b6 When a scope is bound to outside of its allowable boundary, AutoDispose will send an error event with an OutsideScopeException to downstream consumers. If you want to customize this behavior, you can use AutoDisposePlugins#setOutsideScopeHandler to intercept these exceptions and rethrow something else or nothing at all. Example AutoDisposePlugins . setOutsideScopeHandler ( t -> { // Swallow the exception, or rethrow it, or throw your own! }) A good use case of this is, say, just silently disposing/logging observers outside of scope exceptions in production but crashing on debug. The supported mechanism to throw this is in ScopeProvider#requestScope() implementations. FillInOutsideScopeExceptionStacktraces \u00b6 If you have your own handling of exceptions in scope boundary events, you can optionally set AutoDisposePlugins#setFillInOutsideScopeExceptionStacktraces to false . This will result in AutoDispose not filling in stacktraces for exceptions, for a potential minor performance boost. AutoDisposeAndroidPlugins \u00b6 Similar to AutoDisposePlugins , this allows you to customize the behavior of AutoDispose in Android environments. MainThreadChecker \u00b6 This plugin allows for supplying a custom BooleanSupplier that can customize how main thread checks work. The conventional use case of this is Android JUnit tests, where the Looper class is not stubbed in the mock android.jar and fails explosively when touched. Another potential use of this at runtime to customize checks for more fine-grained main thread checks behavior. Example AutoDisposeAndroidPlugins . setOnCheckMainThread (() -> { return true ; // Use whatever heuristics you prefer. }) Behavior \u00b6 Under the hood, AutoDispose decorates RxJava\u2019s real observer with a custom AutoDisposing observer. This custom observer leverages the scope to create a disposable, auto-disposing observer that acts as a lambda observer (pass-through) unless the underlying scope CompletableSource emits onComplete . Both scope emission and upstream termination result in immediate disposable of both the underlying scope subscription and upstream disposable. These custom AutoDisposing observers are considered public read-only API, and can be found under the observers package. They also support retrieval of the underlying observer via delegateObserver() methods. Read-only API means that the public signatures will follow semantic versioning, but we may add new methods in the future (which would break compilation if you make custom implementations!). To read this information, you can use RxJava\u2019s onSubscribe hooks in RxJavaPlugins to watch for instances of these observers. Support/Extensions \u00b6 Flowable , ParallelFlowable , Observable , Maybe , Single , and Completable are all supported. Implementation is solely based on their Observer types, so conceivably any type that uses those for subscription should work. Extensions \u00b6 There are also a number of extension artifacts available, detailed below. LifecycleScopeProvider \u00b6 public interface LifecycleScopeProvider < E > extends ScopeProvider { Observable < E > lifecycle (); Function < E , E > correspondingEvents (); E peekLifecycle (); // Inherited from ScopeProvider CompletableSource requestScope (); } A common use case for this is objects that have implicit lifecycles, such as Android\u2019s Activity , Fragment , and View classes. Internally at subscription-time, AutoDispose will resolve a CompletableSource representation of the target end event in the lifecycle, and exposes an API to dictate what corresponding events are for the current lifecycle state (e.g. ATTACH -> DETACH ). This also allows you to enforce lifecycle boundary requirements, and by default will error if the lifecycle has either not started yet or has already ended. LifecycleScopeProvider is a special case targeted at binding to things with lifecycles. Its API is as follows: - lifecycle() - returns an Observable of lifecycle events. This should be backed by a BehaviorSubject or something similar ( BehaviorRelay , etc). - correspondingEvents() - a mapping of events to corresponding ones, i.e. Attach -> Detach. - peekLifecycle() - returns the current lifecycle state of the object. In requestScope() , the implementation expects to these pieces to construct a CompletableSource representation of the proper end scope, while also doing precondition checks for lifecycle boundaries. If a lifecycle has not started, it will send you to onError with a LifecycleNotStartedException . If the lifecycle as ended, it is recommended to throw a LifecycleEndedException in your correspondingEvents() mapping, but it is up to the user. To simplify implementations, there\u2019s an included LifecycleScopes utility class with factories for generating CompletableSource representations from LifecycleScopeProvider instances. autodispose-lifecycle contains the core LifecycleScopeProvider and LifecycleScopes APIs as well as a convenience test helper. Android \u00b6 There are three artifacts with extra support for Android: * autodispose-android has a ViewScopeProvider for use with Android View classes. * autodispose-androidx-lifecycle has a AndroidLifecycleScopeProvider for use with LifecycleOwner and Lifecycle implementations. Note that the project is compiled against Java 8. If you need support for lower Java versions, you should use D8 (Android Gradle Plugin 3.2+) or desugar as needed (depending on the build system). Kotlin \u00b6 Kotlin extensions are bundled with almost every artifact. For coroutines - there is an autodispose-coroutines-interop artifact for interoperability between CoroutineScope and ScopeProvider / Completable types. RxLifecycle \u00b6 As of 0.4.0 there is an RxLifecycle interop module under autodispose-rxlifecycle . This is for interop with RxLifecycle \u2018s LifecycleProvider interfaces. Philosophy \u00b6 Each factory returns a subscribe proxies upon application that just proxy to real subscribe calls under the hood to \u201cAutoDisposing\u201d implementations of the types. These types decorate the actual observer at subscribe-time to achieve autodispose behavior. The types are not exposed directly because autodisposing has ordering requirements; specifically, it has to be done at the end of a chain to properly wrap all the upstream behavior. Lint could catch this too, but we have seen no use cases for disposing upstream (which can cause a lot of unexpected behavior). Thus, we optimize for the common case, and the API is designed to prevent ordering issues while still being a drop-in one-liner. Motivations \u00b6 Lifecycle management with RxJava and Android is nothing new, so why yet another tool? Two common patterns for binding execution in RxJava that we used prior to this were as follows: CompositeSubscription field that all subscriptions had to be manually added to. RxLifecycle , which works via compose() to resolve the lifecycle end event and ultimately transform the given observable to takeUntil() that event is emitted. Both implementations are elegant and work well, but came with caveats that we sought to revisit and solve in AutoDispose. CompositeSubscription requires manual capture of the return value of subscribe calls, and gets tedious to reason about with regards to binding subscription until different events. RxLifecycle solves the caveats of CompositeSubscription use by working in a dead-simple API and handling resolution of corresponding events. It works great for Observable types, but due to the nature of how takeUntil() works, we found that Single and Completable usage was risky to use (particularly in a large team with varying levels of RxJava experience) considering lifecycle interruption would result in a downstream CancellationException every time. It\u2019s the contract of those types, but induced a lot of ceremony for what would otherwise likely be our most commonly used type ( Single ). Even with Observable , we were still burned occasionally by the completion event still coming through to an unsuspecting engineer. Another caveat we often ran into (and later aggressively linted against) was that the compose() call had ordering implications, and needed to be as close to the subscribe() call as possible to properly wrap upstream. If binding to views, there were also threading requirements on the observable chain in order to work properly. At the end of the day, we wanted true disposal/unsubscription-based behavior, but with RxLifecycle-esque semantics around scope resolution. RxJava 2\u2019s Observer interfaces provide the perfect mechanism for this via their onSubscribe() callbacks. The result is de-risked Single / Completable usage, no ordering concerns, no threading concerns (fingers crossed), and true disposal with no further events of any kind upon scope end. We\u2019re quite happy with it, and hope the community finds it useful as well. Special thanks go to Dan Lew (creator of RxLifecycle), who helped pioneer this area for RxJava in android and humored many of the discussions around lifecycle handling over the past couple years that we\u2019ve learned from. Much of the internal scope resolution mechanics of AutoDispose are inspired by RxLifecycle. RxJava versions support \u00b6 RxJava 3 AutoDispose 2.x RxJava 2 AutoDispose 1.x RxJava 1 We do not plan to try to backport this to RxJava 1. This pattern is sort of possible in RxJava 1, but only on Subscriber (via onStart() ) and CompletableObserver (which matches the API of RxJava 2+). 2.x versions of AutoDispose are built for RxJava 3. Static analysis \u00b6 Error Prone \u00b6 There is an optional error-prone checker you can use to enforce use of AutoDispose. Integration steps and more details can be found on the website Lint Check \u00b6 AutoDispose ships with a lint check that detects missing AutoDispose scope within defined scoped elements. Integration steps and more details can be found on the website Download \u00b6 Java: implementation 'com.uber.autodispose2:autodispose:x.y.z' LifecycleScopeProvider: implementation 'com.uber.autodispose2:autodispose-lifecycle:x.y.z' Android extensions: implementation 'com.uber.autodispose2:autodispose-android:x.y.z' Android Architecture Components extensions: // AutoDispose 1.x implementation 'com.uber.autodispose:autodispose-android-archcomponents:x.y.z' // AutoDispose 2.x implementation 'com.uber.autodispose2:autodispose-androidx-lifecycle:x.y.z' Androidx-Lifecycle Test extensions: // AutoDispose 1.x implementation 'com.uber.autodispose:autodispose-android-archcomponents-test:x.y.z' // AutoDispose 2.x implementation 'com.uber.autodispose2:autodispose-androidx-lifecycle-test:x.y.z' RxLifecycle interop (AutoDispose 1.x/RxJava 2.x only): autodispose-rxlifecycle implementation 'com.uber.autodispose:autodispose-rxlifecycle:x.y.z' autodispose-rxlifecycle3 implementation 'com.uber.autodispose:autodispose-rxlifecycle3:x.y.z' Javadocs and KDocs for the most recent release can be found here: https://uber.github.io/AutoDispose/2.x/autodispose/ Snapshots of the development version are available in Sonatype\u2019s snapshots repository .","title":"Overview"},{"location":"#autodispose","text":"AutoDispose is an RxJava 2+ tool for automatically binding the execution of RxJava streams to a provided scope via disposal/cancellation.","title":"AutoDispose"},{"location":"#overview","text":"Often (especially in mobile applications), Rx subscriptions need to stop in response to some event (for instance, when Activity#onStop() executes in an Android app). In order to support this common scenario in RxJava 2, we built AutoDispose. The idea is simple: construct your chain like any other, and then at subscription you simply drop in the relevant factory call + method for that type as a converter. In everyday use, it usually looks like this: myObservable . doStuff () . as ( autoDisposable ( this )) // The magic . subscribe ( s -> ...); By doing this, you will automatically unsubscribe from myObservable as indicated by your scope - this helps prevent many classes of errors when an observable emits an item, but the actions taken in the subscription are no longer valid. For instance, if a network request comes back after a UI has already been torn down, the UI can\u2019t be updated - this pattern prevents this type of bug.","title":"Overview"},{"location":"#autodisposable","text":"The main entry point is via static factory autoDisposable() methods in the AutoDispose class. There are two overloads: Completable and ScopeProvider . They return an AutoDisposeConverter object that implements all the RxJava Converter interfaces for use with the as() operator in RxJava types.","title":"autoDisposable()"},{"location":"#completable-as-a-scope","text":"The Completable semantic is modeled after the takeUntil() operator, which accepts an Observable whose first emission is used as a notification to signal completion. This is logically the behavior of a Single , so we choose to make that explicit. Since the type doesn\u2019t matter, we simplify this further to just be a Completable , where the scope-end emission is just a completion event. All scopes in AutoDispose eventually resolve to a Completable that emits the end-of-scope notification in onComplete . onError will pass through to the underlying subscription.","title":"Completable (as a scope)"},{"location":"#scopeprovider","text":"public interface ScopeProvider { CompletableSource requestScope () throws Exception ; } ScopeProvider is an abstraction that allows objects to expose and control and provide their own scopes. This is particularly useful for objects with simple scopes (\u201cstop when I stop\u201d) or very custom state that requires custom handling. Note that Exceptions can be thrown in this, and will be routed through onError() . If the thrown exception is an instance of OutsideScopeException , it will be routed through any OutsideScopeHandler s (more below) first, and sent through onError() if not handled.","title":"ScopeProvider"},{"location":"#autodisposeplugins","text":"Modeled after RxJava\u2019s plugins, this allows you to customize the behavior of AutoDispose.","title":"AutoDisposePlugins"},{"location":"#outsidescopehandler","text":"When a scope is bound to outside of its allowable boundary, AutoDispose will send an error event with an OutsideScopeException to downstream consumers. If you want to customize this behavior, you can use AutoDisposePlugins#setOutsideScopeHandler to intercept these exceptions and rethrow something else or nothing at all. Example AutoDisposePlugins . setOutsideScopeHandler ( t -> { // Swallow the exception, or rethrow it, or throw your own! }) A good use case of this is, say, just silently disposing/logging observers outside of scope exceptions in production but crashing on debug. The supported mechanism to throw this is in ScopeProvider#requestScope() implementations.","title":"OutsideScopeHandler"},{"location":"#fillinoutsidescopeexceptionstacktraces","text":"If you have your own handling of exceptions in scope boundary events, you can optionally set AutoDisposePlugins#setFillInOutsideScopeExceptionStacktraces to false . This will result in AutoDispose not filling in stacktraces for exceptions, for a potential minor performance boost.","title":"FillInOutsideScopeExceptionStacktraces"},{"location":"#autodisposeandroidplugins","text":"Similar to AutoDisposePlugins , this allows you to customize the behavior of AutoDispose in Android environments.","title":"AutoDisposeAndroidPlugins"},{"location":"#mainthreadchecker","text":"This plugin allows for supplying a custom BooleanSupplier that can customize how main thread checks work. The conventional use case of this is Android JUnit tests, where the Looper class is not stubbed in the mock android.jar and fails explosively when touched. Another potential use of this at runtime to customize checks for more fine-grained main thread checks behavior. Example AutoDisposeAndroidPlugins . setOnCheckMainThread (() -> { return true ; // Use whatever heuristics you prefer. })","title":"MainThreadChecker"},{"location":"#behavior","text":"Under the hood, AutoDispose decorates RxJava\u2019s real observer with a custom AutoDisposing observer. This custom observer leverages the scope to create a disposable, auto-disposing observer that acts as a lambda observer (pass-through) unless the underlying scope CompletableSource emits onComplete . Both scope emission and upstream termination result in immediate disposable of both the underlying scope subscription and upstream disposable. These custom AutoDisposing observers are considered public read-only API, and can be found under the observers package. They also support retrieval of the underlying observer via delegateObserver() methods. Read-only API means that the public signatures will follow semantic versioning, but we may add new methods in the future (which would break compilation if you make custom implementations!). To read this information, you can use RxJava\u2019s onSubscribe hooks in RxJavaPlugins to watch for instances of these observers.","title":"Behavior"},{"location":"#supportextensions","text":"Flowable , ParallelFlowable , Observable , Maybe , Single , and Completable are all supported. Implementation is solely based on their Observer types, so conceivably any type that uses those for subscription should work.","title":"Support/Extensions"},{"location":"#extensions","text":"There are also a number of extension artifacts available, detailed below.","title":"Extensions"},{"location":"#lifecyclescopeprovider","text":"public interface LifecycleScopeProvider < E > extends ScopeProvider { Observable < E > lifecycle (); Function < E , E > correspondingEvents (); E peekLifecycle (); // Inherited from ScopeProvider CompletableSource requestScope (); } A common use case for this is objects that have implicit lifecycles, such as Android\u2019s Activity , Fragment , and View classes. Internally at subscription-time, AutoDispose will resolve a CompletableSource representation of the target end event in the lifecycle, and exposes an API to dictate what corresponding events are for the current lifecycle state (e.g. ATTACH -> DETACH ). This also allows you to enforce lifecycle boundary requirements, and by default will error if the lifecycle has either not started yet or has already ended. LifecycleScopeProvider is a special case targeted at binding to things with lifecycles. Its API is as follows: - lifecycle() - returns an Observable of lifecycle events. This should be backed by a BehaviorSubject or something similar ( BehaviorRelay , etc). - correspondingEvents() - a mapping of events to corresponding ones, i.e. Attach -> Detach. - peekLifecycle() - returns the current lifecycle state of the object. In requestScope() , the implementation expects to these pieces to construct a CompletableSource representation of the proper end scope, while also doing precondition checks for lifecycle boundaries. If a lifecycle has not started, it will send you to onError with a LifecycleNotStartedException . If the lifecycle as ended, it is recommended to throw a LifecycleEndedException in your correspondingEvents() mapping, but it is up to the user. To simplify implementations, there\u2019s an included LifecycleScopes utility class with factories for generating CompletableSource representations from LifecycleScopeProvider instances. autodispose-lifecycle contains the core LifecycleScopeProvider and LifecycleScopes APIs as well as a convenience test helper.","title":"LifecycleScopeProvider"},{"location":"#android","text":"There are three artifacts with extra support for Android: * autodispose-android has a ViewScopeProvider for use with Android View classes. * autodispose-androidx-lifecycle has a AndroidLifecycleScopeProvider for use with LifecycleOwner and Lifecycle implementations. Note that the project is compiled against Java 8. If you need support for lower Java versions, you should use D8 (Android Gradle Plugin 3.2+) or desugar as needed (depending on the build system).","title":"Android"},{"location":"#kotlin","text":"Kotlin extensions are bundled with almost every artifact. For coroutines - there is an autodispose-coroutines-interop artifact for interoperability between CoroutineScope and ScopeProvider / Completable types.","title":"Kotlin"},{"location":"#rxlifecycle","text":"As of 0.4.0 there is an RxLifecycle interop module under autodispose-rxlifecycle . This is for interop with RxLifecycle \u2018s LifecycleProvider interfaces.","title":"RxLifecycle"},{"location":"#philosophy","text":"Each factory returns a subscribe proxies upon application that just proxy to real subscribe calls under the hood to \u201cAutoDisposing\u201d implementations of the types. These types decorate the actual observer at subscribe-time to achieve autodispose behavior. The types are not exposed directly because autodisposing has ordering requirements; specifically, it has to be done at the end of a chain to properly wrap all the upstream behavior. Lint could catch this too, but we have seen no use cases for disposing upstream (which can cause a lot of unexpected behavior). Thus, we optimize for the common case, and the API is designed to prevent ordering issues while still being a drop-in one-liner.","title":"Philosophy"},{"location":"#motivations","text":"Lifecycle management with RxJava and Android is nothing new, so why yet another tool? Two common patterns for binding execution in RxJava that we used prior to this were as follows: CompositeSubscription field that all subscriptions had to be manually added to. RxLifecycle , which works via compose() to resolve the lifecycle end event and ultimately transform the given observable to takeUntil() that event is emitted. Both implementations are elegant and work well, but came with caveats that we sought to revisit and solve in AutoDispose. CompositeSubscription requires manual capture of the return value of subscribe calls, and gets tedious to reason about with regards to binding subscription until different events. RxLifecycle solves the caveats of CompositeSubscription use by working in a dead-simple API and handling resolution of corresponding events. It works great for Observable types, but due to the nature of how takeUntil() works, we found that Single and Completable usage was risky to use (particularly in a large team with varying levels of RxJava experience) considering lifecycle interruption would result in a downstream CancellationException every time. It\u2019s the contract of those types, but induced a lot of ceremony for what would otherwise likely be our most commonly used type ( Single ). Even with Observable , we were still burned occasionally by the completion event still coming through to an unsuspecting engineer. Another caveat we often ran into (and later aggressively linted against) was that the compose() call had ordering implications, and needed to be as close to the subscribe() call as possible to properly wrap upstream. If binding to views, there were also threading requirements on the observable chain in order to work properly. At the end of the day, we wanted true disposal/unsubscription-based behavior, but with RxLifecycle-esque semantics around scope resolution. RxJava 2\u2019s Observer interfaces provide the perfect mechanism for this via their onSubscribe() callbacks. The result is de-risked Single / Completable usage, no ordering concerns, no threading concerns (fingers crossed), and true disposal with no further events of any kind upon scope end. We\u2019re quite happy with it, and hope the community finds it useful as well. Special thanks go to Dan Lew (creator of RxLifecycle), who helped pioneer this area for RxJava in android and humored many of the discussions around lifecycle handling over the past couple years that we\u2019ve learned from. Much of the internal scope resolution mechanics of AutoDispose are inspired by RxLifecycle.","title":"Motivations"},{"location":"#rxjava-versions-support","text":"RxJava 3 AutoDispose 2.x RxJava 2 AutoDispose 1.x RxJava 1 We do not plan to try to backport this to RxJava 1. This pattern is sort of possible in RxJava 1, but only on Subscriber (via onStart() ) and CompletableObserver (which matches the API of RxJava 2+). 2.x versions of AutoDispose are built for RxJava 3.","title":"RxJava versions support"},{"location":"#static-analysis","text":"","title":"Static analysis"},{"location":"#error-prone","text":"There is an optional error-prone checker you can use to enforce use of AutoDispose. Integration steps and more details can be found on the website","title":"Error Prone"},{"location":"#lint-check","text":"AutoDispose ships with a lint check that detects missing AutoDispose scope within defined scoped elements. Integration steps and more details can be found on the website","title":"Lint Check"},{"location":"#download","text":"Java: implementation 'com.uber.autodispose2:autodispose:x.y.z' LifecycleScopeProvider: implementation 'com.uber.autodispose2:autodispose-lifecycle:x.y.z' Android extensions: implementation 'com.uber.autodispose2:autodispose-android:x.y.z' Android Architecture Components extensions: // AutoDispose 1.x implementation 'com.uber.autodispose:autodispose-android-archcomponents:x.y.z' // AutoDispose 2.x implementation 'com.uber.autodispose2:autodispose-androidx-lifecycle:x.y.z' Androidx-Lifecycle Test extensions: // AutoDispose 1.x implementation 'com.uber.autodispose:autodispose-android-archcomponents-test:x.y.z' // AutoDispose 2.x implementation 'com.uber.autodispose2:autodispose-androidx-lifecycle-test:x.y.z' RxLifecycle interop (AutoDispose 1.x/RxJava 2.x only): autodispose-rxlifecycle implementation 'com.uber.autodispose:autodispose-rxlifecycle:x.y.z' autodispose-rxlifecycle3 implementation 'com.uber.autodispose:autodispose-rxlifecycle3:x.y.z' Javadocs and KDocs for the most recent release can be found here: https://uber.github.io/AutoDispose/2.x/autodispose/ Snapshots of the development version are available in Sonatype\u2019s snapshots repository .","title":"Download"},{"location":"changelog/","text":"Changelog \u00b6 Version 2.1.0 \u00b6 2021-08-09 Add @NonNull or : Any to type arguments where appropriate for better nullability contracts in generics. Fix lint using \u201cmainProject\u201d instead of \u201cproject\u201d, meaning this now supports AGP 7.0.0. Add lint support for RxKotlin extensions or your own extensions See the docs for configuration details! Lint is now published as a dedicated artifact for use in pure JVM projects. plugins { id \"org.jetbrains.kotlin.jvm\" id \"com.android.lint\" } dependencies { lintChecks \"com.uber.autodispose2:autodispose-lint:<version>\" } Deprecate TestLifecycleOwner artifact + its extensions in favor of the first party androidx.lifecycle.testing.TestLifecycleOwner option. See an example migration in this PR . Update to RxJava 3.1.0 Update to Kotlin 1.5.21 Update to androidx.lifecycle 2.3.1 Update to Error-Prone 2.8.1 Update to kotlinx.coroutines 1.5.1 Update to lint 30.0.0 Note that we are no longer releasing AutoDispose 1.x versions as RxJava 2 reached End of Life in February 2021. Thanks to @Rajin9601 , @ianhanniballake , @rafaeltoledo , and @msridhar for contributing to this release! Version 2.0.0 \u00b6 2020-02-23 AutoDispose 2 is built against RxJava 3 and is binary-compatible with AutoDispose 1.x and RxJava 2.x. As such - it has a different package name and maven group ID. Packaging \u00b6 Maven Group ID Package Name 1.x com.uber.autodispose com.uber.autodispose 2.x com.uber.autodispose2 autodispose2 For any sub-packages, the above mapping should be used for those package prefix replacements as well. Changes \u00b6 All deprecated APIs in 1.x have been removed. This consisted exclusively of deprecated Kotlin autoDisposable extension functions that were deprecated in 1.4.0. The autodispose-android-archcomponents* artifacts have been renamed to to autodispose-androidx-lifecycle* to match the androidx-lifecycle library they correspond to. The lint and error prone checks have also been updated. At the time of writing, there is no RxLifecycle with RxJava 3 support yet, and as such there is no AutoDispose 2.x interop artifact for RxLifecycle. We can add this back if there\u2019s a new RxLifecycle release with RxJava 3.x support. You can find migration steps on the project site at https://uber.github.io/AutoDispose/migrating-1x-2x/ . Version 2.0.0-RC2 \u00b6 2019-12-02 RC2 has no additional changes from RC1 but does not upload RCs for Android artifacts since RxAndroid does not have a RC yet. Version 2.0.0-RC1 \u00b6 2019-12-01 This is the first release candidate for AutoDispose 2.0 AutoDispose 2 is built against RxJava 3 and is binary-compatible with AutoDispose 1.x and RxJava 2.x. As such - it has a different package name and maven group ID. Android not supported yet \u00b6 Due to there being no RxAndroid 3.x release candidate, we cannot release RCs of the Android artifacts yet. They are available as snapshots though. Packaging \u00b6 Maven Group ID Package Name 1.x com.uber.autodispose com.uber.autodispose 2.x com.uber.autodispose2 autodispose2 For any sub-packages, the above mapping should be used for those package prefix replacements as well. Changes \u00b6 All deprecated APIs in 1.x have been removed. This consisted exclusively of deprecated Kotlin autoDisposable extension functions that were deprecated in 1.4.0. The autodispose-android-archcomponents* artifacts have been renamed to to autodispose-androidx-lifecycle* to match the androidx-lifecycle library they correspond to. The lint and error prone checks have also been updated. We may look at consolidating these before 2.0 final is released if the community wants. At the time of writing, there is no RxLifecycle with RxJava 3 support yet, and as such there is no AutoDispose 2.x interop artifact for RxLifecycle. We can add this back if there\u2019s a new RxLifecycle release with RxJava 3.x support. We\u2019ll be maintaining a running document of migration steps on the project site at https://uber.github.io/AutoDispose/migrating-1x-2x/ . Version 1.4.0 \u00b6 2019-09-18 Kotlin CoroutineScope interop #374 \u00b6 Interop functions for CoroutineScope to ScopeProvider / Completable (and vice versa) are now available in a new autodispose-coroutines-interop artifact. This is not intended to allow AutoDispose\u2019s scoping machinery be a competitor for it, but rather just a tool for interop-ing codebases that use both or aid in migrations. Kotlin API naming improvements #372 #377 \u00b6 To better differentiate between the AutoDispose classes\u2019s autoDisposable() methods (which return Rx converter types), the Kotlin autoDisposable() extensions have been deprecated in favor of a more idiomatic autoDispose() verb form name. The old extensions have been annotated with @Deprecated and replacements, so this should be an easy one time migration. myObservable . autoDispose ( scope ) . subscribe () Fused proxy types #376 \u00b6 AutoDispose\u2019s analogous Rx types ( AutoDisposeObservable , etc) have been updated to implement their *SubscribeProxy interfaces directly. The current behavior of subscribe proxies is best thought of as similar to hide() . Subscribe proxies have always wrapped the AutoDispose\u2019s analogous Rx types to prevent upcasting. If your team are good citizens though, you can now disable proxy hiding via AutoDisposePlugins to save that extra allocation. New withScope() API #375 #378 \u00b6 There is a new Kotlin withScope() API that accepts a scope and a body to execute in. This body is a function-with-receiver tied to a new AutoDisposeContext interface, which has no-arg autoDispose() functions in it. This allows for calling autoDispose() within the context of the body and allow the enclosing context manage wiring the applied scope to it. @Test fun example () = withScope ( scope ) { Observable . just ( \"Hello withScope()!\" ) . autoDispose () . subscribe () } Dependency updates \u00b6 Kotlin: 1.3.50 Lint tools: 26.5.0 Version 1.3.0 \u00b6 2019-05-15 Unified Kotlin extensions \u00b6 Starting with 1.3.0, all the -ktx artifacts and their kotlin extensions have been merged into the main artifacts they extended. This means that extensions in an artifact like autodispose-android-ktx are now available directly in the corresponding autodispose-android . This is a binary-compatible change because the extensions file name has changed while the extensions themselves have remained in the same package. So in essence, import com.uber.autodispose.autoDisposable still works as-is. Just remove the ktx artifact dependencies and everything will still link as-is! The Kotlin standard library has been added as an compileOnly dependency of artifacts containing Kotlin bindings. This is to avoid imposing the dependency for non-Kotlin users, but the expectation is for Kotlin users to bring their own standard library dependency to fulfill this if used. Considering the standard library is an ubiquitous dependency for Kotlin projects, we don\u2019t expect this to be an issue and drew inspiration for this design from Retrofit . Proguard/R8 .pro files in the unified artifacts have been updated to not warn on these KotlinExtensions files as they can be safely stripped in builds if unused. NOTE: One important thing this revealed was that the ktx artifacts were built with jdk target 1.6, while depending on Java artifacts that were built against JDK 8. Now that they are unified, this means that the Kotlin extensions require targeting JDK 1.8 as well (configurable via compiler arg -jvm-target=1.8 ). PRs: #339 #341 #346 More Kotlin extensions! \u00b6 Initially, we only provided minimal Kotlin extensions to support scopes on extra types like Android\u2019s LifecycleOwner , View , etc. This resulted in a bit of ceremony for these APIs to be used though, such as: Observable . just ( 1 ) . autoDisposable ( AndroidLifecycleScopeProvider . from ( this )) . subscribe () To simplify this, we\u2019ve added the following top-level extension functions for the following: * autodispose-android - View * autodispose-archcomponents - LifecycleOwner * autodispose-rxlifecycle - LifecycleProvider * autodispose-rxlifecycle3 - LifecycleProvider So now, the above snippet could just be: Observable . just ( 1 ) . autoDisposable ( this ) . subscribe () PRs: #348 #353 Removed deprecated lifecycle artifacts \u00b6 Following their deprecating in 1.1.0, the autodispose-lifecycle-jdk8 and autodispose-lifecycle-ktx artifacts are no longer published. Please move to just using LifecycleScopeProvider directly. Misc \u00b6 Dependency updates Kotlin: 1.3.31 AndroidX Annotations: 1.0.2 RxJava: 2.2.8 RxAndroid: 2.1.1 Artifact changes Original Merged into (if applicable) autodispose-ktx autodispose autodispose-android-ktx autodispose-android autodispose-android-archcomponents-ktx autodispose-android-archcomponents autodispose-android-archcomponents-test-ktx autodispose-android-archcomponents-test autodispose-lifecycle-ktx N/A autodispose-lifecycle-jdk8 N/A Note: This does not mean the existing versions were deleted or removed in any way, just that we will not publish 1.3.0 or later versions of them. Version 1.2.0 \u00b6 2019-04-03 Fixes a bug which allows Lint to refer to the app level gradle.properties file for configuration support. #335 New autodispose-rxlifeycle3 artifact for interop with RxLifecycle3. #319 Various dependency updates Lint: 26.3.2 Kotlin 1.3.21 All PRs: #319 , #320 , #322 , #326 , #327 #328 , #329 , #330 , #334 , #335 , #336 Version 1.1.0 \u00b6 2018-12-13 Static Analysis \u00b6 This is a big static analysis release. AutoDispose now ships with two static analysis artifacts: autodispose-lint for Android Lint and autodispose-error-prone for Error-Prone. Both of these checks operate by detecting uses of standard RxJava subscribe / subscribeWith calls in the context of something that has scope (such as a ScopeProvider ). If they\u2019re detected, the lint/checker will mark them as missing Disposable handling and suggest either using AutoDispose or (if lenient mode enabled) manually handle the returned Disposable . Both checks have configuration support: TypesWithScope - a comma-separated list of custom types with scope. By default, this is additive to default scopes. OverrideScopes - a boolean flag indicating if TypesWithScope should override the built-in scopes. false by default. Lenient - a boolean flag to enable a lenient mode that tells the linter to ignore cases where the returned Disposable is captured (aka \u201cI know what I\u2019m doing\u201d mode). false by default. Both checkers should have feature parity. They have different advantages: the Error-Prone check runs at compile-time, and lint will show up in the IDE and run on Kotlin code. You should use whichever one fits your stack best. Full integration instructions can be found on their respective wikis: https://github.com/uber/AutoDispose/wiki/Lint-Check https://github.com/uber/AutoDispose/wiki/Error-Prone Prior to this release, the Error Prone checker was missing a required service file to run, so the new artifact is different than the previous one (but not conflicting since the old one never worked!). This was a major project and contribution from a new maintainer to the project! @shaishavgandhi05 All PRs: #316 , #315 , #313 , #312 , #310 , #307 , #308 , #306 , #299 , #303 , #301 , #300 , #282 , #291 , #292 DefaultLifecycleScopeProvider and KotlinLifecycleScopeProvider Deprecation ( #275 ) \u00b6 DefaultLifecycleScopeProvider and KotlinLifecycleScopeProvider are now deprecated, and their default requestScope() behavior now elevated into the based LifecycleScopeProvider class. This is implemented as a Java 8 default interface method. Misc \u00b6 Non-android -ktx artifacts now use implementation / api dependencies ( #277 ) automatic-module-name is added to relevant JDK modules ( #281 ) Updated doc on RxLifecycleInterop ( #280 ) Kotlin is updated to 1.3.11 #274 , #309 Thanks to the following external contributors for this release: @MarkyC Version 1.0.0 \u00b6 2018-10-10 Stable release! This is identical in functionality to 1.0.0-RC3 but completely migrated to the new AndroidX artifacts. From this point forward for Android projects, you must be on AndroidX artifacts. You can use 1.0.0-RC3 to ease migration if need be. Version 1.0.0-RC3 \u00b6 2018-10-10 The project now targets Java 8 bytecode, with the expectation that projects are either on Java 8 or (if on Android) use D8 via Android Gradle Plugin 3.2.0. ( #257 ) More sample recipes for Android ViewModels and Fragments ( #254 ) ( #260 ) Various dependency updates Support library 28.0.0 Architecture Components (runtime) 1.1.1 Kotlin 1.2.71 RxJava 2.2.2 RxAndroid 2.1.0 Thanks to the following contributors for this release: @shaishavgandhi05 Version 1.0.0-RC2 \u00b6 2018-8-14 Small followup update to RC1 subscribe(Observer) methods in SubscribeProxy interfaces now accept wildcards for the observer type, matching their RxJava counterparts ( #244 ) Example: subscribe(Observer<T> observer) -> subscribe(Observer<? super T> observer) Kotlin artifacts now include Module.md files in dokka documentation ( #238 ) Android lifecycle Kotlin scope() extensions now return ScopeProvider instead of LifecycleScopeProvider ( #239 ) Thanks to the following contributors for this release: @shaishavgandhi05 Version 1.0.0-RC1 \u00b6 2018-8-2 This is the first release candidate of AutoDispose 1.0! Completable replaces Maybe as the source of truth for scoping ( #234 ) \u00b6 Note: we say Completable for semantic convenience, but in code it\u2019s almost always referred to via CompletableSource for flexibility This is a significant API change, but a good one we want to clean up before releasing 1.0. Since its inception, AutoDispose has always coerced scopes into a Maybe representation. Now, scopes are coerced to a CompletableSource . Maybe seemed like the right idea for something that \u201cmay or may not emit\u201d, but in our case we actually don\u2019t care about the difference between onSuccess or onComplete. We did have a notion of \u201cUNBOUND\u201d, but that doesn\u2019t offer anything other than a severed lifecycle scope disposal in an atomic reference (no other cleanups would happen for gc, etc). This brings us to a Single . The thing is though, we don\u2019t care about the object/element type. A Single where the type doesn\u2019t matter is semantically a Completable , and thus this change. Note that semantics are slightly different for anyone that sourced scope via emissions from an Observable , Maybe , Completable , or Flowable , where before a completion event would not trigger disposal. Now it would. In the lifecycle artifact, completion of the lifecycle or emission of the target event (via takeUntil() ) will signal disposal. If there\u2019s a strong desire for it, we could look at adding top-level autoDisposable overrides that accept other RxJava types (and coerce them to Completable ). Lifecycle components are now a separate artifact ( #228 ) \u00b6 LifecycleScopeProvider is now in a separate artifact under autodispose-lifecycle , and now just extends ScopeProvider . This is sort of something we always wanted to do, as the recommended solution for AutoDispose is namely to use ScopeProvider and standard RxJava types. LifecycleScopeProvider supports corresponding-events-type lifecycles for use with lifecycle components like Android, but we mostly see this as a mechanism for boundary checks. Dan Lew excellently discusses this subject in his \u201c Why Not RxLifecycle? \u201d blog post. This does come with the caveat that one must implement requestScope() in implementations now. To smoothen this usage, a autodispose-lifecycle-jdk8 artifact exists with a DefaultLifecycleScopeProvider that has a default implementation of this on Java 8+ that matches the existing behavior. A similar default behavior was added for the autodispose-lifecycle-ktx artifact. These behaviors can be further tuned via factory helpers in LifecycleScopes . Other notable changes in this: * OutsideLifecycleException has been renamed to OutsideScopeException and kept in the core artifact. Boundary checks can be done and respected in ScopeProvider implementations, and corresponding AutoDisposePlugins for this have been renamed accordingly. * correspondingEvents() now returns a CorrespondingEventsFunction , which is a narrower subtype of Function that only needs one generic and only allows for throwing `OutsideScopeException. Misc \u00b6 All deprecated APIs have been removed. Kotlin Artifacts have been renamed to be {name}-ktx instead of {name}-kotlin to match other library conventions. Kotlin artifacts with .ktx or .kotlin package name entries have had them removed to match convention with other ktx-style artifacts. i.e. Instead of com.uber.autodispose.kotlin , it would just be com.uber.autodispose . ViewScopeProvider now uses a custom MainThreadDisposable that respects any main thread checks set via AutoDisposeAndroidPlugins . ( #232 ) Jetbrains annotations have been removed in favor of just using RxJava\u2019s @Nullable annotation directly. Saves some proguard rules and dependencies, and also makes annotation usage consistent. The following dependencies have been updated: RxJava 2.2.0 ( as() and ParallelFlowable are now stable APIs) Kotlin 1.2.60 Build against Android SDK 28 Support library 27.1.1 RxLifecycle 2.2.2 RxAndroid 2.0.2 The sample app has had some wonderful community contributions LeakCanary integration Architecture components sample , including ViewModel and using a repository pattern General structure cleanup This is an RC1. We won\u2019t release 1.0 final until the AndroidX artifacts are stable to save ourselves from having to release a 2.0 immediately after this. These are a lot of breaking changes, so please let us know if you see any issues. Thanks to the following contributors for this release: @shaishavgandhi05 and @remcomokveld Version 0.8.0 \u00b6 2018-5-7 Deprecated Scoper APIs now use the converter API under the hood ( #188 ) \u00b6 Up to this point, the new as() -based converter APIs just delegated to the existing deprecated to() APIs. In this release, they have been flipped, such that the to() APIs now just point to the as() -based APIs. This should be no visible user change, but please let us know if you see any issues. ViewScopeProvider now implements ScopeProvider instead of LifecycleScopeProvider ( #196 ) \u00b6 We believe this makes more sense, as there\u2019s no beginning boundary check for Views that we can check and the general attach state is quite simple. This also avoids leaking an unnecessary internal API. Defer to Comparable checks if LifecycleScopeProvider types implement it ( #196 ) \u00b6 For better flexibility, if a type for LifecycleScopeProvider implements Comparable , we will defer to it rather than equals() . This allows for consumers to better convey event ordering to the scope provider, and allow AutoDispose to catch events after a target event as a fallback. This covers cases where the targeted \u201cend\u201d event is missed but a later event comes through, allowing AutoDispose to dispose anyway. Note that this may result in a behavior change if your lifecycle types implemented Comparable before. Removed Error-Prone annotations ( #208 ) \u00b6 As of Error-Prone 2.3.1, @DoNotMock was removed. We\u2019ve switched to an internal copy of this annotation for documentation purposes and for any external checkers to still check this usage on their own (by name). Switch from JSR305 to Jetbrains annotations for nullability ( #208 ) \u00b6 To be compatible with the Java 9 module system, we\u2019ve switched away from the JSR 305 annotations/javax-extras on packages and now use the Jetbrains annotations for nullability instead. We still abide by a nonnull-by-default implementation, and only annotate nullable elements with @Nullable . This dependency, like JSR305/javax-extras, is compileOnly . Misc changes \u00b6 A few miscellaneous IDE warnings ( #208 ) We are now building against Android Gradle Plugin 3.1.x (latest stable) ( #190 ) Due to ongoing Dokka issues and update latency, we\u2019ve had to disable it on Kotlin artifacts for now. We plan to re-enable on the next release, which should add compatibility for AGP 3.x+. Call for input on next steps \u00b6 We have two major design proposals that we want community feedback on that would take shape in the next couple of releases. Please let us know if you have any thoughts! Kotlin rewrite: #198 Extract LifecycleScopeProvider to separate artifact, make it extend ScopeProvider: #197 Thanks to the following contributors for this release: @tbsandee , @atexannamedbob Version 0.7.0 \u00b6 2018-3-26 AutoDisposeAndroidPlugins ( #183 ) \u00b6 New API! AutoDisposeAndroidPlugins API for plugin hooks to AutoDispose\u2019s android behavior at runtime. The first plugin supported here is MainThreadChecker . This plugin allows for supplying a custom BooleanSupplier that can customize how main thread checks work. The conventional use case of this is Android JUnit tests, where the Looper class is not stubbed in the mock android.jar and fails explosively when touched. Another potential use of this at runtime to customize checks for more fine-grained main thread checks behavior. Example AutoDisposeAndroidPlugins . setOnCheckMainThread (() -> { return true ; // Use whatever heuristics you prefer. }) This is available in the autodispose-android artifact, and all mainthread-checking APIs in android artifacts will delegate to this plugin hook. Misc \u00b6 Fixed a few nullability and other minor warnings ( #187 ) Contributed by @tbsandee ! Version 0.6.1 \u00b6 2018-2-23 This is patch release with a couple of QoL improvements: * Android artifacts\u2019 consumer proguard rules have been updated to not warn on the compiled error-prone annotations, like @DoNotMock ( #178 ) * Contributed by @danh32 ! * Android artifacts no longer bundle a useless BuildConfig.java file ( #177 ) Version 0.6.0 \u00b6 2018-2-5 Error-Prone Checker artifact ( #156 ) \u00b6 There is a new Error-Prone checker artifact that you can optionally apply to have error-prone enforced checks that rx chains are autodisposed when executing in a class that has scope. This is experimental in the public, but has been used extensively internally at Uber for nearly a year. Please let us know if you run into any issues! Wiki page with setup and configuration instructions: https://github.com/uber/AutoDispose/wiki/Error-Prone-Checker We plan to add a UAST lint artifact in the future as well. ParallelFlowable support ( #155 ) \u00b6 AutoDispose now supports RxJava\u2019s ParallelFlowable type. Note that this only works through the new as() API, and there is no ParallelScoper API (since those are being removed in 1.0). ScopeProvider and LifecycleScopeProvider are now annotated with @DoNotMock ( #153 ) \u00b6 These types have specific test helpers that will be more robust for long term test usage, and thus should not be mocked. Convenience test() methods added to all SubscribeProxy interfaces ( #160 ) \u00b6 These are to match the convenience test() methods in regular RxJava types. Misc \u00b6 Archcomponents updated to 1.1.0 for compatibility with new artifacts ( #128 ) autodispose-android-archcomponents-test and autodispose-android-archcomponents-test-kotlin now only depend on the common arch components artifact rather than extensions , which removes the unused livedata and viewmodel transitive dependencies. RxViewHolder examples now implement LifecycleScopeProvider instead of ScopeProvider ( #157 ) Deprecated Kotlin APIs are now ERROR level instead of WARNING ( #151 ) Various doc fixes ( #158 ) RxLifecycle updated to 2.2.1 ( #161 ) ErrorProne annotations updated to 2.2.0 ( #161 ) Android artifacts now compiled against SDK 27 Android support annotations updated to 27.0.2 Thanks to the following contributors! @VisheshVadhera @bangarharshit @mmallozzi @0legg @shaunkawano Version 0.5.1 \u00b6 2017-12-6 Fix: A bug where unbound scopes would mark the observer as disposed, subsequently preventing future events from emitting. ( #149 ) Fix: Kotlin docs accidentally pointing to to() operators instead of as() . ( #145 ) Snapshots should be fully working now as well. Version 0.5.0 \u00b6 2017-12-3 New converter-based API for use with as() ( #141 ) \u00b6 AutoDispose\u2019s primary API is now via static autoDisposable() methods on the AutoDispose class. The previous to() based APIs are now completely deprecated, and will be removed in AutoDispose 1.0. This has been sort of the long-standing ideal API for AutoDispose for awhile, but wasn\u2019t possible until the introduction of the new as() operator in RxJava. As this operator is still not marked as stable (and won\u2019t until RxJava 2.2.0), AutoDispose will not be updated to 1.0 until then. The main difference is that you no longer have to specify the type indirection, and the returned converter is applicable for all 5 RxJava types. In use, it looks like this: Flowable . just ( 1 ) . as ( autoDisposable ( scope )) . subscribe () Observable . just ( 1 ) . as ( autoDisposable ( scope )) . subscribe () Maybe . just ( 1 ) . as ( autoDisposable ( scope )) . subscribe () Single . just ( 1 ) . as ( autoDisposable ( scope )) . subscribe () Completable . complete () . as ( autoDisposable ( scope )) . subscribe () There are three overloads for autoDisposable() , for each of the three scope types ( Maybe , ScopeProvider , and LifecycleScopeProvider ). The Kotlin bindings have also been updated to match semantics, with the autoDisposeWith extension functions being deprecated in favor of analogous autoDisposable . These are WARNING level in this release, and will become ERROR in AutoDispose 0.6.0, before finally being removed in 1.0. They also provide replaceWith options (compatible with Kotlin\u2019s deprecation quickfixes). autoDisposable reads best when statically imported (so you can do .as(autoDisposable(...)) , which you can safely do if you\u2019re using Java 8. For structural replace templates, see here ). Fixed a lot of concurrency edge cases and performance improvements after review from David Karnok ( #138 and #130 ) \u00b6 David Karnok (@akarnokd, RxJava project lead) did an audit of the current codebase and gave extensive feedback in #130. #138 implements that feedback. This handled a lot of concurrency gotchas and edge cases we were missing before. See the issue and PR for full details. Plugin for controlling whether or not to fill in stacktraces ( #124 ) \u00b6 AutoDisposePlugins has a new API to control whether or not lifecycle exception stacktraces are filled in. What this means is that if you opt out, the exceptions thrown in LifecycleScopeProvider boundary issues will no longer have a stacktrace ( getStacktrace() will return an empty array) and only carry the type name and message. This can be useful to gain some performance if you track stacktracing via other means. UNBOUND shorthand ( #125 ) \u00b6 ScopeProvider has a static instance of an \u201cunbound\u201d provider directly in the interface now for reuse. This obviates the need for TestScopeProvider#unbound() , which has been removed . Usage is simple: Observable . just ( 1 ) . as ( autoDisposable ( ScopeProvider . UNBOUND )) . subscribe () Misc \u00b6 Archcomponents updated to 1.0.0 final ( #128 ) RxJava dependency is now 2.1.7 (to leverage as() ) ( #141 ) Kotlin is now updated to 1.2.0 ( #141 ) Dokka is wired up, meaning that kotlin artifacts now also have exported javadocs. ( #126 ) subscribeBy example extension in the sample app displaying how you can add extension functions to the *SubscribeProxy classes. ( #127 ) delegateObserver() APIs on AutoDisposing observers have been promoted to stable. Considering they are useful for subscribeWith() , we can just keep it observer-based and keep the library more flexible long-term ( #144 ) Thanks to the following contributors! @charlesdurham @ajalt @tbsandee @akarnokd Version 0.4.0 \u00b6 2017-10-22 Structured Android Components #111 \u00b6 Android components have been split up into several artifacts under :android : - autodispose-android : Core android utilities, previously :autodispose-android - autodispose-android-archcomponents : Utilities for lifecycles in android archcomponents, previously :autodispose-android-archcomponents but does not have the test helper - New: autodispose-android-archcomponents-test : Test utilities for working with arch components, namely TestLifecycleOwner , formerly TestAndroidLifecycleScopeProvider . - This allows us to remove the extensions dependency from the main arch components artifact and keep this optional. This API can also be used for general use testing for arch components, as it\u2019s not actually specific to AutoDispose. - New: autodispose-android-kotlin : kotlin bindings for autodispose-android - New: autodispose-android-archcomponents-kotlin : kotlin bindings for autodispose-android-archcomponents - New: autodispose-android-archcomponents-test-kotlin : kotlin bindings for autodispose-android-test-archcomponents - New: Android artifacts include consumer proguard rules (relates to ( #112 )) Related changes: - Fix: Arch components updated to 1.0.0-rc1 , which should fix compatibility issues noted in ( #113 ) - Enhancement: untilEvent overload for AndroidLifecycleScopeProvider ( #107 ) - Now you can bind until a specific target event, or provide your own boundary provider function - Behavior change: previously, anything occurring after ON_STOP would resolve to ON_DESTROY . Now, they resolve to stop on the next destruction event. This brings it inline with the modern behavior of arch components version -rc1 . - Enhancement: AndroidLifecycleScopeProvider s are now reusable. This is somewhat experimental, as it works by dynamically resolving the last event based on the state. Please report any issues! #121 RxLifecycle Interop \u00b6 A new autodispose-rxlifecycle interop module was added, adding support for scoping to RxLifecycle \u2018s LifecycleProvider API. ( #118 ) Misc \u00b6 Reduced object allocations ( #108 ) Convenience unbound() factory on TestScopeProvider ( #108 ) Removed synthetic accessors ( #103 ) Updated to Kotlin 1.1.51 ( #116 ) Thanks to the following contributors! @rubengees @bangarharshit Updated dependencies: \u00b6 Android Arch Components: 1.0.0-rc1 Android Arch Components (common): 1.0.3 Kotlin: 1.1.51 New artifacts coordinates: \u00b6 compile 'com.uber.autodispose:autodispose-android-archcomponents-test:x.y.z' compile 'com.uber.autodispose:autodispose-rxlifecycle:x.y.z' compile 'com.uber.autodispose:autodispose-android-kotlin:x.y.z' compile 'com.uber.autodispose:autodispose-android-archcomponents-kotlin:x.y.z' compile 'com.uber.autodispose:autodispose-android-archcomponents-test-kotlin:x.y.z' Version 0.3.0 \u00b6 2017-10-01 New: Static factory API ( #88 ) After a long time trying to figure out how to finagle this in a way that played nice with IDE autocomplete, the main API for AutoDispose is now via the AutoDispose class and its static factories. Observable ( 1 ) . to ( AutoDispose . with ( yourScope ). forObservable ()) . subscribe (); // Note: on Java 7, you must specify the generic. The IDE should autocomplete this for you. Observable ( 1 ) . to ( AutoDispose . with ( yourScope ). < Integer > forObservable ()) . subscribe (); with() has three overloads for Maybe , ScopeProvider , and LifecycleScopeProvider . They return an intermediary ScopeHandler , which in turn has 5 generic for___() methods that correspond to the 5 RxJava types ( Observable , Flowable , Single , Maybe , and Completable ). The old Scoper class are now deprecated , and will be removed in AutoDispose 1.0. Fortunately, this is easy to migrate via IntelliJ\u2019s structural replace. Information can be found here . New: Support for Android Architecture Components! ( #71 ) With the beta release of architecture components, they are now supported in the autodispose-android-archcomponents artifact. Observable ( 1 ) . to ( AutoDispose . with ( AndroidLifecycleScopeProvider . from ( this )). forObservable ()) . subscribe (); Where this could be anything that implements LifecycleOwner or extends Lifecycle . compile 'com.uber.autodispose:autodispose-android-archcomponents:x.y.z' Thanks to @yigit , @jaychang0917 , and @lsvijay for their help and contributions on this! New: Delegate Observer retrieval ( #89 ) Every automatically disposing observer implements one of the corresponding AutoDisposing____Observer interfaces in the com.uber.autodispose.observers package. They are considered read-only public API, with the intention that you can look for them in the RxJava plugin system (such as an onSubscribe hook). This extends their functionality to expose a new experimental API called delegateObserver() . This allows you to access the underlying observer that this is automatically disposing. The reason for this is that there may be conditions where you want to handle functionality depending on information from that Observer. As of RxJava 2.1.4, one such case could be to read information from a LambdaConsumerIntrospection ( relevant PR ). In the future, this will likely be narrowed to return a @Nullable lambdaConsumerIntrospection() , but we\u2019re open to feedback if others think this should remain the high level Observer type. Thanks to @mswysocki for his contribution on this! New: JSR 305 Nullability Annotations ( #79 ) AutoDispose packages now leverage JSR 305 annotations to indicate nullability. By default, all methods and parameters are non-null by default. This uses the spin-off javax-extras artifact for method nullability support, and is only a compileOnly dependency (so it should show up) for tooling but is not packaged as a compile dependency. Further reading: https://medium.com/square-corner-blog/non-null-is-the-default-58ffc0bb9111 New: Sample android app! ( #97 ) For a long time, AutoDispose relied on tests and the README to be demonstrations of API use. It\u2019s become clear that this is not enough information though, so we\u2019ve added a full sample app (borrowing heavily from RxLifecycle/Conductor\u2019s) to better illustrate API usage and runtime behavior. We\u2019ll continue to iterate on this over time. Improved: EndConsumerHelper ( #77 ) AutoDispose uses the same disposal-helper utilities as RxJava. This updates to RxJava\u2019s new EndConsumerHelper , which should hopefully help produce more helpful error messages in disposal error conditions. Other Updated various dependencies: Android Arch Components: 1.0.0-beta1 Android Support Library: 26.1.0 (to match arch components) Kotlin: 1.1.50 As always, we welcome any and all discussions/feedback/PRs! We\u2019re marching toward a 1.0 release Real Soon Now, so now is the time. There are a few outstanding discussion issues in the issue tracker about 1.0 final design decisions. Version 0.2.0 \u00b6 2017-05-08 New: Kotlin artifact! (#47) This adds autoDisposeWith() extensions to RxJava types. myObservable . doWhatever () . autoDisposeWith ( this ) . subscribe () New: Plugin system! (#57) Modeled after RxJava\u2019s plugins, this allows you to customize the behavior of AutoDispose with lifecycle boundary checks. AutoDisposePlugins . setOutsideLifecycleHandler ( t -> { // Swallow the exception, or rethrow it, or throw your own! }) A good use case of this is, say, just silently disposing/logging observers outside of lifecycle exceptions in production but crashing on debug. New: Test helpers! (#48 #49) Two helpers were added to simulate conditions in testing. - TestLifecycleScopeProvider - This has two corresponding lifecycle methods: start() and stop() - TestScopeProvider - Has just one method - emit() . For testing with just the Maybe<?> scope, we recommend using RxJava\u2019s built-in MaybeSubject . Fix : Fixed a race condition where upstream wouldn\u2019t be disposed if the lifecycle emitted or error\u2019d synchronously (i.e. was already terminated). (#57) Fix : Add missing @CheckReturnValue annotations to subscribeWith methods. (#53) Other tidbits: - Removed @NonNull annotations. Everything is @NonNull by default, and only elements annotated with @Nullable are not. - Use of the new java-library plugin for gradle (#64). The RxJava dependencies are marked as api . - Error prone has been integrated. Currently the annotations are just marked as compileOnly , but if a need arises/community wants them - we can compile them in a future version. Version 0.1.0 \u00b6 2017-03-13 Initial release","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#version-210","text":"2021-08-09 Add @NonNull or : Any to type arguments where appropriate for better nullability contracts in generics. Fix lint using \u201cmainProject\u201d instead of \u201cproject\u201d, meaning this now supports AGP 7.0.0. Add lint support for RxKotlin extensions or your own extensions See the docs for configuration details! Lint is now published as a dedicated artifact for use in pure JVM projects. plugins { id \"org.jetbrains.kotlin.jvm\" id \"com.android.lint\" } dependencies { lintChecks \"com.uber.autodispose2:autodispose-lint:<version>\" } Deprecate TestLifecycleOwner artifact + its extensions in favor of the first party androidx.lifecycle.testing.TestLifecycleOwner option. See an example migration in this PR . Update to RxJava 3.1.0 Update to Kotlin 1.5.21 Update to androidx.lifecycle 2.3.1 Update to Error-Prone 2.8.1 Update to kotlinx.coroutines 1.5.1 Update to lint 30.0.0 Note that we are no longer releasing AutoDispose 1.x versions as RxJava 2 reached End of Life in February 2021. Thanks to @Rajin9601 , @ianhanniballake , @rafaeltoledo , and @msridhar for contributing to this release!","title":"Version 2.1.0"},{"location":"changelog/#version-200","text":"2020-02-23 AutoDispose 2 is built against RxJava 3 and is binary-compatible with AutoDispose 1.x and RxJava 2.x. As such - it has a different package name and maven group ID.","title":"Version 2.0.0"},{"location":"changelog/#packaging","text":"Maven Group ID Package Name 1.x com.uber.autodispose com.uber.autodispose 2.x com.uber.autodispose2 autodispose2 For any sub-packages, the above mapping should be used for those package prefix replacements as well.","title":"Packaging"},{"location":"changelog/#changes","text":"All deprecated APIs in 1.x have been removed. This consisted exclusively of deprecated Kotlin autoDisposable extension functions that were deprecated in 1.4.0. The autodispose-android-archcomponents* artifacts have been renamed to to autodispose-androidx-lifecycle* to match the androidx-lifecycle library they correspond to. The lint and error prone checks have also been updated. At the time of writing, there is no RxLifecycle with RxJava 3 support yet, and as such there is no AutoDispose 2.x interop artifact for RxLifecycle. We can add this back if there\u2019s a new RxLifecycle release with RxJava 3.x support. You can find migration steps on the project site at https://uber.github.io/AutoDispose/migrating-1x-2x/ .","title":"Changes"},{"location":"changelog/#version-200-rc2","text":"2019-12-02 RC2 has no additional changes from RC1 but does not upload RCs for Android artifacts since RxAndroid does not have a RC yet.","title":"Version 2.0.0-RC2"},{"location":"changelog/#version-200-rc1","text":"2019-12-01 This is the first release candidate for AutoDispose 2.0 AutoDispose 2 is built against RxJava 3 and is binary-compatible with AutoDispose 1.x and RxJava 2.x. As such - it has a different package name and maven group ID.","title":"Version 2.0.0-RC1"},{"location":"changelog/#android-not-supported-yet","text":"Due to there being no RxAndroid 3.x release candidate, we cannot release RCs of the Android artifacts yet. They are available as snapshots though.","title":"Android not supported yet"},{"location":"changelog/#packaging_1","text":"Maven Group ID Package Name 1.x com.uber.autodispose com.uber.autodispose 2.x com.uber.autodispose2 autodispose2 For any sub-packages, the above mapping should be used for those package prefix replacements as well.","title":"Packaging"},{"location":"changelog/#changes_1","text":"All deprecated APIs in 1.x have been removed. This consisted exclusively of deprecated Kotlin autoDisposable extension functions that were deprecated in 1.4.0. The autodispose-android-archcomponents* artifacts have been renamed to to autodispose-androidx-lifecycle* to match the androidx-lifecycle library they correspond to. The lint and error prone checks have also been updated. We may look at consolidating these before 2.0 final is released if the community wants. At the time of writing, there is no RxLifecycle with RxJava 3 support yet, and as such there is no AutoDispose 2.x interop artifact for RxLifecycle. We can add this back if there\u2019s a new RxLifecycle release with RxJava 3.x support. We\u2019ll be maintaining a running document of migration steps on the project site at https://uber.github.io/AutoDispose/migrating-1x-2x/ .","title":"Changes"},{"location":"changelog/#version-140","text":"2019-09-18","title":"Version 1.4.0"},{"location":"changelog/#kotlin-coroutinescope-interop-374","text":"Interop functions for CoroutineScope to ScopeProvider / Completable (and vice versa) are now available in a new autodispose-coroutines-interop artifact. This is not intended to allow AutoDispose\u2019s scoping machinery be a competitor for it, but rather just a tool for interop-ing codebases that use both or aid in migrations.","title":"Kotlin CoroutineScope interop #374"},{"location":"changelog/#kotlin-api-naming-improvements-372-377","text":"To better differentiate between the AutoDispose classes\u2019s autoDisposable() methods (which return Rx converter types), the Kotlin autoDisposable() extensions have been deprecated in favor of a more idiomatic autoDispose() verb form name. The old extensions have been annotated with @Deprecated and replacements, so this should be an easy one time migration. myObservable . autoDispose ( scope ) . subscribe ()","title":"Kotlin API naming improvements #372 #377"},{"location":"changelog/#fused-proxy-types-376","text":"AutoDispose\u2019s analogous Rx types ( AutoDisposeObservable , etc) have been updated to implement their *SubscribeProxy interfaces directly. The current behavior of subscribe proxies is best thought of as similar to hide() . Subscribe proxies have always wrapped the AutoDispose\u2019s analogous Rx types to prevent upcasting. If your team are good citizens though, you can now disable proxy hiding via AutoDisposePlugins to save that extra allocation.","title":"Fused proxy types #376"},{"location":"changelog/#new-withscope-api-375-378","text":"There is a new Kotlin withScope() API that accepts a scope and a body to execute in. This body is a function-with-receiver tied to a new AutoDisposeContext interface, which has no-arg autoDispose() functions in it. This allows for calling autoDispose() within the context of the body and allow the enclosing context manage wiring the applied scope to it. @Test fun example () = withScope ( scope ) { Observable . just ( \"Hello withScope()!\" ) . autoDispose () . subscribe () }","title":"New withScope() API #375 #378"},{"location":"changelog/#dependency-updates","text":"Kotlin: 1.3.50 Lint tools: 26.5.0","title":"Dependency updates"},{"location":"changelog/#version-130","text":"2019-05-15","title":"Version 1.3.0"},{"location":"changelog/#unified-kotlin-extensions","text":"Starting with 1.3.0, all the -ktx artifacts and their kotlin extensions have been merged into the main artifacts they extended. This means that extensions in an artifact like autodispose-android-ktx are now available directly in the corresponding autodispose-android . This is a binary-compatible change because the extensions file name has changed while the extensions themselves have remained in the same package. So in essence, import com.uber.autodispose.autoDisposable still works as-is. Just remove the ktx artifact dependencies and everything will still link as-is! The Kotlin standard library has been added as an compileOnly dependency of artifacts containing Kotlin bindings. This is to avoid imposing the dependency for non-Kotlin users, but the expectation is for Kotlin users to bring their own standard library dependency to fulfill this if used. Considering the standard library is an ubiquitous dependency for Kotlin projects, we don\u2019t expect this to be an issue and drew inspiration for this design from Retrofit . Proguard/R8 .pro files in the unified artifacts have been updated to not warn on these KotlinExtensions files as they can be safely stripped in builds if unused. NOTE: One important thing this revealed was that the ktx artifacts were built with jdk target 1.6, while depending on Java artifacts that were built against JDK 8. Now that they are unified, this means that the Kotlin extensions require targeting JDK 1.8 as well (configurable via compiler arg -jvm-target=1.8 ). PRs: #339 #341 #346","title":"Unified Kotlin extensions"},{"location":"changelog/#more-kotlin-extensions","text":"Initially, we only provided minimal Kotlin extensions to support scopes on extra types like Android\u2019s LifecycleOwner , View , etc. This resulted in a bit of ceremony for these APIs to be used though, such as: Observable . just ( 1 ) . autoDisposable ( AndroidLifecycleScopeProvider . from ( this )) . subscribe () To simplify this, we\u2019ve added the following top-level extension functions for the following: * autodispose-android - View * autodispose-archcomponents - LifecycleOwner * autodispose-rxlifecycle - LifecycleProvider * autodispose-rxlifecycle3 - LifecycleProvider So now, the above snippet could just be: Observable . just ( 1 ) . autoDisposable ( this ) . subscribe () PRs: #348 #353","title":"More Kotlin extensions!"},{"location":"changelog/#removed-deprecated-lifecycle-artifacts","text":"Following their deprecating in 1.1.0, the autodispose-lifecycle-jdk8 and autodispose-lifecycle-ktx artifacts are no longer published. Please move to just using LifecycleScopeProvider directly.","title":"Removed deprecated lifecycle artifacts"},{"location":"changelog/#misc","text":"Dependency updates Kotlin: 1.3.31 AndroidX Annotations: 1.0.2 RxJava: 2.2.8 RxAndroid: 2.1.1 Artifact changes Original Merged into (if applicable) autodispose-ktx autodispose autodispose-android-ktx autodispose-android autodispose-android-archcomponents-ktx autodispose-android-archcomponents autodispose-android-archcomponents-test-ktx autodispose-android-archcomponents-test autodispose-lifecycle-ktx N/A autodispose-lifecycle-jdk8 N/A Note: This does not mean the existing versions were deleted or removed in any way, just that we will not publish 1.3.0 or later versions of them.","title":"Misc"},{"location":"changelog/#version-120","text":"2019-04-03 Fixes a bug which allows Lint to refer to the app level gradle.properties file for configuration support. #335 New autodispose-rxlifeycle3 artifact for interop with RxLifecycle3. #319 Various dependency updates Lint: 26.3.2 Kotlin 1.3.21 All PRs: #319 , #320 , #322 , #326 , #327 #328 , #329 , #330 , #334 , #335 , #336","title":"Version 1.2.0"},{"location":"changelog/#version-110","text":"2018-12-13","title":"Version 1.1.0"},{"location":"changelog/#static-analysis","text":"This is a big static analysis release. AutoDispose now ships with two static analysis artifacts: autodispose-lint for Android Lint and autodispose-error-prone for Error-Prone. Both of these checks operate by detecting uses of standard RxJava subscribe / subscribeWith calls in the context of something that has scope (such as a ScopeProvider ). If they\u2019re detected, the lint/checker will mark them as missing Disposable handling and suggest either using AutoDispose or (if lenient mode enabled) manually handle the returned Disposable . Both checks have configuration support: TypesWithScope - a comma-separated list of custom types with scope. By default, this is additive to default scopes. OverrideScopes - a boolean flag indicating if TypesWithScope should override the built-in scopes. false by default. Lenient - a boolean flag to enable a lenient mode that tells the linter to ignore cases where the returned Disposable is captured (aka \u201cI know what I\u2019m doing\u201d mode). false by default. Both checkers should have feature parity. They have different advantages: the Error-Prone check runs at compile-time, and lint will show up in the IDE and run on Kotlin code. You should use whichever one fits your stack best. Full integration instructions can be found on their respective wikis: https://github.com/uber/AutoDispose/wiki/Lint-Check https://github.com/uber/AutoDispose/wiki/Error-Prone Prior to this release, the Error Prone checker was missing a required service file to run, so the new artifact is different than the previous one (but not conflicting since the old one never worked!). This was a major project and contribution from a new maintainer to the project! @shaishavgandhi05 All PRs: #316 , #315 , #313 , #312 , #310 , #307 , #308 , #306 , #299 , #303 , #301 , #300 , #282 , #291 , #292","title":"Static Analysis"},{"location":"changelog/#defaultlifecyclescopeprovider-and-kotlinlifecyclescopeprovider-deprecation-275","text":"DefaultLifecycleScopeProvider and KotlinLifecycleScopeProvider are now deprecated, and their default requestScope() behavior now elevated into the based LifecycleScopeProvider class. This is implemented as a Java 8 default interface method.","title":"DefaultLifecycleScopeProvider and KotlinLifecycleScopeProvider Deprecation (#275)"},{"location":"changelog/#misc_1","text":"Non-android -ktx artifacts now use implementation / api dependencies ( #277 ) automatic-module-name is added to relevant JDK modules ( #281 ) Updated doc on RxLifecycleInterop ( #280 ) Kotlin is updated to 1.3.11 #274 , #309 Thanks to the following external contributors for this release: @MarkyC","title":"Misc"},{"location":"changelog/#version-100","text":"2018-10-10 Stable release! This is identical in functionality to 1.0.0-RC3 but completely migrated to the new AndroidX artifacts. From this point forward for Android projects, you must be on AndroidX artifacts. You can use 1.0.0-RC3 to ease migration if need be.","title":"Version 1.0.0"},{"location":"changelog/#version-100-rc3","text":"2018-10-10 The project now targets Java 8 bytecode, with the expectation that projects are either on Java 8 or (if on Android) use D8 via Android Gradle Plugin 3.2.0. ( #257 ) More sample recipes for Android ViewModels and Fragments ( #254 ) ( #260 ) Various dependency updates Support library 28.0.0 Architecture Components (runtime) 1.1.1 Kotlin 1.2.71 RxJava 2.2.2 RxAndroid 2.1.0 Thanks to the following contributors for this release: @shaishavgandhi05","title":"Version 1.0.0-RC3"},{"location":"changelog/#version-100-rc2","text":"2018-8-14 Small followup update to RC1 subscribe(Observer) methods in SubscribeProxy interfaces now accept wildcards for the observer type, matching their RxJava counterparts ( #244 ) Example: subscribe(Observer<T> observer) -> subscribe(Observer<? super T> observer) Kotlin artifacts now include Module.md files in dokka documentation ( #238 ) Android lifecycle Kotlin scope() extensions now return ScopeProvider instead of LifecycleScopeProvider ( #239 ) Thanks to the following contributors for this release: @shaishavgandhi05","title":"Version 1.0.0-RC2"},{"location":"changelog/#version-100-rc1","text":"2018-8-2 This is the first release candidate of AutoDispose 1.0!","title":"Version 1.0.0-RC1"},{"location":"changelog/#completable-replaces-maybe-as-the-source-of-truth-for-scoping-234","text":"Note: we say Completable for semantic convenience, but in code it\u2019s almost always referred to via CompletableSource for flexibility This is a significant API change, but a good one we want to clean up before releasing 1.0. Since its inception, AutoDispose has always coerced scopes into a Maybe representation. Now, scopes are coerced to a CompletableSource . Maybe seemed like the right idea for something that \u201cmay or may not emit\u201d, but in our case we actually don\u2019t care about the difference between onSuccess or onComplete. We did have a notion of \u201cUNBOUND\u201d, but that doesn\u2019t offer anything other than a severed lifecycle scope disposal in an atomic reference (no other cleanups would happen for gc, etc). This brings us to a Single . The thing is though, we don\u2019t care about the object/element type. A Single where the type doesn\u2019t matter is semantically a Completable , and thus this change. Note that semantics are slightly different for anyone that sourced scope via emissions from an Observable , Maybe , Completable , or Flowable , where before a completion event would not trigger disposal. Now it would. In the lifecycle artifact, completion of the lifecycle or emission of the target event (via takeUntil() ) will signal disposal. If there\u2019s a strong desire for it, we could look at adding top-level autoDisposable overrides that accept other RxJava types (and coerce them to Completable ).","title":"Completable replaces Maybe as the source of truth for scoping (#234)"},{"location":"changelog/#lifecycle-components-are-now-a-separate-artifact-228","text":"LifecycleScopeProvider is now in a separate artifact under autodispose-lifecycle , and now just extends ScopeProvider . This is sort of something we always wanted to do, as the recommended solution for AutoDispose is namely to use ScopeProvider and standard RxJava types. LifecycleScopeProvider supports corresponding-events-type lifecycles for use with lifecycle components like Android, but we mostly see this as a mechanism for boundary checks. Dan Lew excellently discusses this subject in his \u201c Why Not RxLifecycle? \u201d blog post. This does come with the caveat that one must implement requestScope() in implementations now. To smoothen this usage, a autodispose-lifecycle-jdk8 artifact exists with a DefaultLifecycleScopeProvider that has a default implementation of this on Java 8+ that matches the existing behavior. A similar default behavior was added for the autodispose-lifecycle-ktx artifact. These behaviors can be further tuned via factory helpers in LifecycleScopes . Other notable changes in this: * OutsideLifecycleException has been renamed to OutsideScopeException and kept in the core artifact. Boundary checks can be done and respected in ScopeProvider implementations, and corresponding AutoDisposePlugins for this have been renamed accordingly. * correspondingEvents() now returns a CorrespondingEventsFunction , which is a narrower subtype of Function that only needs one generic and only allows for throwing `OutsideScopeException.","title":"Lifecycle components are now a separate artifact (#228)"},{"location":"changelog/#misc_2","text":"All deprecated APIs have been removed. Kotlin Artifacts have been renamed to be {name}-ktx instead of {name}-kotlin to match other library conventions. Kotlin artifacts with .ktx or .kotlin package name entries have had them removed to match convention with other ktx-style artifacts. i.e. Instead of com.uber.autodispose.kotlin , it would just be com.uber.autodispose . ViewScopeProvider now uses a custom MainThreadDisposable that respects any main thread checks set via AutoDisposeAndroidPlugins . ( #232 ) Jetbrains annotations have been removed in favor of just using RxJava\u2019s @Nullable annotation directly. Saves some proguard rules and dependencies, and also makes annotation usage consistent. The following dependencies have been updated: RxJava 2.2.0 ( as() and ParallelFlowable are now stable APIs) Kotlin 1.2.60 Build against Android SDK 28 Support library 27.1.1 RxLifecycle 2.2.2 RxAndroid 2.0.2 The sample app has had some wonderful community contributions LeakCanary integration Architecture components sample , including ViewModel and using a repository pattern General structure cleanup This is an RC1. We won\u2019t release 1.0 final until the AndroidX artifacts are stable to save ourselves from having to release a 2.0 immediately after this. These are a lot of breaking changes, so please let us know if you see any issues. Thanks to the following contributors for this release: @shaishavgandhi05 and @remcomokveld","title":"Misc"},{"location":"changelog/#version-080","text":"2018-5-7","title":"Version 0.8.0"},{"location":"changelog/#deprecated-scoper-apis-now-use-the-converter-api-under-the-hood-188","text":"Up to this point, the new as() -based converter APIs just delegated to the existing deprecated to() APIs. In this release, they have been flipped, such that the to() APIs now just point to the as() -based APIs. This should be no visible user change, but please let us know if you see any issues.","title":"Deprecated Scoper APIs now use the converter API under the hood (#188)"},{"location":"changelog/#viewscopeprovider-now-implements-scopeprovider-instead-of-lifecyclescopeprovider-196","text":"We believe this makes more sense, as there\u2019s no beginning boundary check for Views that we can check and the general attach state is quite simple. This also avoids leaking an unnecessary internal API.","title":"ViewScopeProvider now implements ScopeProvider instead of LifecycleScopeProvider (#196)"},{"location":"changelog/#defer-to-comparable-checks-if-lifecyclescopeprovider-types-implement-it-196","text":"For better flexibility, if a type for LifecycleScopeProvider implements Comparable , we will defer to it rather than equals() . This allows for consumers to better convey event ordering to the scope provider, and allow AutoDispose to catch events after a target event as a fallback. This covers cases where the targeted \u201cend\u201d event is missed but a later event comes through, allowing AutoDispose to dispose anyway. Note that this may result in a behavior change if your lifecycle types implemented Comparable before.","title":"Defer to Comparable checks if LifecycleScopeProvider types implement it (#196)"},{"location":"changelog/#removed-error-prone-annotations-208","text":"As of Error-Prone 2.3.1, @DoNotMock was removed. We\u2019ve switched to an internal copy of this annotation for documentation purposes and for any external checkers to still check this usage on their own (by name).","title":"Removed Error-Prone annotations (#208)"},{"location":"changelog/#switch-from-jsr305-to-jetbrains-annotations-for-nullability-208","text":"To be compatible with the Java 9 module system, we\u2019ve switched away from the JSR 305 annotations/javax-extras on packages and now use the Jetbrains annotations for nullability instead. We still abide by a nonnull-by-default implementation, and only annotate nullable elements with @Nullable . This dependency, like JSR305/javax-extras, is compileOnly .","title":"Switch from JSR305 to Jetbrains annotations for nullability (#208)"},{"location":"changelog/#misc-changes","text":"A few miscellaneous IDE warnings ( #208 ) We are now building against Android Gradle Plugin 3.1.x (latest stable) ( #190 ) Due to ongoing Dokka issues and update latency, we\u2019ve had to disable it on Kotlin artifacts for now. We plan to re-enable on the next release, which should add compatibility for AGP 3.x+.","title":"Misc changes"},{"location":"changelog/#call-for-input-on-next-steps","text":"We have two major design proposals that we want community feedback on that would take shape in the next couple of releases. Please let us know if you have any thoughts! Kotlin rewrite: #198 Extract LifecycleScopeProvider to separate artifact, make it extend ScopeProvider: #197 Thanks to the following contributors for this release: @tbsandee , @atexannamedbob","title":"Call for input on next steps"},{"location":"changelog/#version-070","text":"2018-3-26","title":"Version 0.7.0"},{"location":"changelog/#autodisposeandroidplugins-183","text":"New API! AutoDisposeAndroidPlugins API for plugin hooks to AutoDispose\u2019s android behavior at runtime. The first plugin supported here is MainThreadChecker . This plugin allows for supplying a custom BooleanSupplier that can customize how main thread checks work. The conventional use case of this is Android JUnit tests, where the Looper class is not stubbed in the mock android.jar and fails explosively when touched. Another potential use of this at runtime to customize checks for more fine-grained main thread checks behavior. Example AutoDisposeAndroidPlugins . setOnCheckMainThread (() -> { return true ; // Use whatever heuristics you prefer. }) This is available in the autodispose-android artifact, and all mainthread-checking APIs in android artifacts will delegate to this plugin hook.","title":"AutoDisposeAndroidPlugins (#183)"},{"location":"changelog/#misc_3","text":"Fixed a few nullability and other minor warnings ( #187 ) Contributed by @tbsandee !","title":"Misc"},{"location":"changelog/#version-061","text":"2018-2-23 This is patch release with a couple of QoL improvements: * Android artifacts\u2019 consumer proguard rules have been updated to not warn on the compiled error-prone annotations, like @DoNotMock ( #178 ) * Contributed by @danh32 ! * Android artifacts no longer bundle a useless BuildConfig.java file ( #177 )","title":"Version 0.6.1"},{"location":"changelog/#version-060","text":"2018-2-5","title":"Version 0.6.0"},{"location":"changelog/#error-prone-checker-artifact-156","text":"There is a new Error-Prone checker artifact that you can optionally apply to have error-prone enforced checks that rx chains are autodisposed when executing in a class that has scope. This is experimental in the public, but has been used extensively internally at Uber for nearly a year. Please let us know if you run into any issues! Wiki page with setup and configuration instructions: https://github.com/uber/AutoDispose/wiki/Error-Prone-Checker We plan to add a UAST lint artifact in the future as well.","title":"Error-Prone Checker artifact (#156)"},{"location":"changelog/#parallelflowable-support-155","text":"AutoDispose now supports RxJava\u2019s ParallelFlowable type. Note that this only works through the new as() API, and there is no ParallelScoper API (since those are being removed in 1.0).","title":"ParallelFlowable support (#155)"},{"location":"changelog/#scopeprovider-and-lifecyclescopeprovider-are-now-annotated-with-donotmock-153","text":"These types have specific test helpers that will be more robust for long term test usage, and thus should not be mocked.","title":"ScopeProvider and LifecycleScopeProvider are now annotated with @DoNotMock (#153)"},{"location":"changelog/#convenience-test-methods-added-to-all-subscribeproxy-interfaces-160","text":"These are to match the convenience test() methods in regular RxJava types.","title":"Convenience test() methods added to all SubscribeProxy interfaces (#160)"},{"location":"changelog/#misc_4","text":"Archcomponents updated to 1.1.0 for compatibility with new artifacts ( #128 ) autodispose-android-archcomponents-test and autodispose-android-archcomponents-test-kotlin now only depend on the common arch components artifact rather than extensions , which removes the unused livedata and viewmodel transitive dependencies. RxViewHolder examples now implement LifecycleScopeProvider instead of ScopeProvider ( #157 ) Deprecated Kotlin APIs are now ERROR level instead of WARNING ( #151 ) Various doc fixes ( #158 ) RxLifecycle updated to 2.2.1 ( #161 ) ErrorProne annotations updated to 2.2.0 ( #161 ) Android artifacts now compiled against SDK 27 Android support annotations updated to 27.0.2 Thanks to the following contributors! @VisheshVadhera @bangarharshit @mmallozzi @0legg @shaunkawano","title":"Misc"},{"location":"changelog/#version-051","text":"2017-12-6 Fix: A bug where unbound scopes would mark the observer as disposed, subsequently preventing future events from emitting. ( #149 ) Fix: Kotlin docs accidentally pointing to to() operators instead of as() . ( #145 ) Snapshots should be fully working now as well.","title":"Version 0.5.1"},{"location":"changelog/#version-050","text":"2017-12-3","title":"Version 0.5.0"},{"location":"changelog/#new-converter-based-api-for-use-with-as-141","text":"AutoDispose\u2019s primary API is now via static autoDisposable() methods on the AutoDispose class. The previous to() based APIs are now completely deprecated, and will be removed in AutoDispose 1.0. This has been sort of the long-standing ideal API for AutoDispose for awhile, but wasn\u2019t possible until the introduction of the new as() operator in RxJava. As this operator is still not marked as stable (and won\u2019t until RxJava 2.2.0), AutoDispose will not be updated to 1.0 until then. The main difference is that you no longer have to specify the type indirection, and the returned converter is applicable for all 5 RxJava types. In use, it looks like this: Flowable . just ( 1 ) . as ( autoDisposable ( scope )) . subscribe () Observable . just ( 1 ) . as ( autoDisposable ( scope )) . subscribe () Maybe . just ( 1 ) . as ( autoDisposable ( scope )) . subscribe () Single . just ( 1 ) . as ( autoDisposable ( scope )) . subscribe () Completable . complete () . as ( autoDisposable ( scope )) . subscribe () There are three overloads for autoDisposable() , for each of the three scope types ( Maybe , ScopeProvider , and LifecycleScopeProvider ). The Kotlin bindings have also been updated to match semantics, with the autoDisposeWith extension functions being deprecated in favor of analogous autoDisposable . These are WARNING level in this release, and will become ERROR in AutoDispose 0.6.0, before finally being removed in 1.0. They also provide replaceWith options (compatible with Kotlin\u2019s deprecation quickfixes). autoDisposable reads best when statically imported (so you can do .as(autoDisposable(...)) , which you can safely do if you\u2019re using Java 8. For structural replace templates, see here ).","title":"New converter-based API for use with as() (#141)"},{"location":"changelog/#fixed-a-lot-of-concurrency-edge-cases-and-performance-improvements-after-review-from-david-karnok-138-and-130","text":"David Karnok (@akarnokd, RxJava project lead) did an audit of the current codebase and gave extensive feedback in #130. #138 implements that feedback. This handled a lot of concurrency gotchas and edge cases we were missing before. See the issue and PR for full details.","title":"Fixed a lot of concurrency edge cases and performance improvements after review from David Karnok (#138 and #130)"},{"location":"changelog/#plugin-for-controlling-whether-or-not-to-fill-in-stacktraces-124","text":"AutoDisposePlugins has a new API to control whether or not lifecycle exception stacktraces are filled in. What this means is that if you opt out, the exceptions thrown in LifecycleScopeProvider boundary issues will no longer have a stacktrace ( getStacktrace() will return an empty array) and only carry the type name and message. This can be useful to gain some performance if you track stacktracing via other means.","title":"Plugin for controlling whether or not to fill in stacktraces (#124)"},{"location":"changelog/#unbound-shorthand-125","text":"ScopeProvider has a static instance of an \u201cunbound\u201d provider directly in the interface now for reuse. This obviates the need for TestScopeProvider#unbound() , which has been removed . Usage is simple: Observable . just ( 1 ) . as ( autoDisposable ( ScopeProvider . UNBOUND )) . subscribe ()","title":"UNBOUND shorthand (#125)"},{"location":"changelog/#misc_5","text":"Archcomponents updated to 1.0.0 final ( #128 ) RxJava dependency is now 2.1.7 (to leverage as() ) ( #141 ) Kotlin is now updated to 1.2.0 ( #141 ) Dokka is wired up, meaning that kotlin artifacts now also have exported javadocs. ( #126 ) subscribeBy example extension in the sample app displaying how you can add extension functions to the *SubscribeProxy classes. ( #127 ) delegateObserver() APIs on AutoDisposing observers have been promoted to stable. Considering they are useful for subscribeWith() , we can just keep it observer-based and keep the library more flexible long-term ( #144 ) Thanks to the following contributors! @charlesdurham @ajalt @tbsandee @akarnokd","title":"Misc"},{"location":"changelog/#version-040","text":"2017-10-22","title":"Version 0.4.0"},{"location":"changelog/#structured-android-components-111","text":"Android components have been split up into several artifacts under :android : - autodispose-android : Core android utilities, previously :autodispose-android - autodispose-android-archcomponents : Utilities for lifecycles in android archcomponents, previously :autodispose-android-archcomponents but does not have the test helper - New: autodispose-android-archcomponents-test : Test utilities for working with arch components, namely TestLifecycleOwner , formerly TestAndroidLifecycleScopeProvider . - This allows us to remove the extensions dependency from the main arch components artifact and keep this optional. This API can also be used for general use testing for arch components, as it\u2019s not actually specific to AutoDispose. - New: autodispose-android-kotlin : kotlin bindings for autodispose-android - New: autodispose-android-archcomponents-kotlin : kotlin bindings for autodispose-android-archcomponents - New: autodispose-android-archcomponents-test-kotlin : kotlin bindings for autodispose-android-test-archcomponents - New: Android artifacts include consumer proguard rules (relates to ( #112 )) Related changes: - Fix: Arch components updated to 1.0.0-rc1 , which should fix compatibility issues noted in ( #113 ) - Enhancement: untilEvent overload for AndroidLifecycleScopeProvider ( #107 ) - Now you can bind until a specific target event, or provide your own boundary provider function - Behavior change: previously, anything occurring after ON_STOP would resolve to ON_DESTROY . Now, they resolve to stop on the next destruction event. This brings it inline with the modern behavior of arch components version -rc1 . - Enhancement: AndroidLifecycleScopeProvider s are now reusable. This is somewhat experimental, as it works by dynamically resolving the last event based on the state. Please report any issues! #121","title":"Structured Android Components #111"},{"location":"changelog/#rxlifecycle-interop","text":"A new autodispose-rxlifecycle interop module was added, adding support for scoping to RxLifecycle \u2018s LifecycleProvider API. ( #118 )","title":"RxLifecycle Interop"},{"location":"changelog/#misc_6","text":"Reduced object allocations ( #108 ) Convenience unbound() factory on TestScopeProvider ( #108 ) Removed synthetic accessors ( #103 ) Updated to Kotlin 1.1.51 ( #116 ) Thanks to the following contributors! @rubengees @bangarharshit","title":"Misc"},{"location":"changelog/#updated-dependencies","text":"Android Arch Components: 1.0.0-rc1 Android Arch Components (common): 1.0.3 Kotlin: 1.1.51","title":"Updated dependencies:"},{"location":"changelog/#new-artifacts-coordinates","text":"compile 'com.uber.autodispose:autodispose-android-archcomponents-test:x.y.z' compile 'com.uber.autodispose:autodispose-rxlifecycle:x.y.z' compile 'com.uber.autodispose:autodispose-android-kotlin:x.y.z' compile 'com.uber.autodispose:autodispose-android-archcomponents-kotlin:x.y.z' compile 'com.uber.autodispose:autodispose-android-archcomponents-test-kotlin:x.y.z'","title":"New artifacts coordinates:"},{"location":"changelog/#version-030","text":"2017-10-01 New: Static factory API ( #88 ) After a long time trying to figure out how to finagle this in a way that played nice with IDE autocomplete, the main API for AutoDispose is now via the AutoDispose class and its static factories. Observable ( 1 ) . to ( AutoDispose . with ( yourScope ). forObservable ()) . subscribe (); // Note: on Java 7, you must specify the generic. The IDE should autocomplete this for you. Observable ( 1 ) . to ( AutoDispose . with ( yourScope ). < Integer > forObservable ()) . subscribe (); with() has three overloads for Maybe , ScopeProvider , and LifecycleScopeProvider . They return an intermediary ScopeHandler , which in turn has 5 generic for___() methods that correspond to the 5 RxJava types ( Observable , Flowable , Single , Maybe , and Completable ). The old Scoper class are now deprecated , and will be removed in AutoDispose 1.0. Fortunately, this is easy to migrate via IntelliJ\u2019s structural replace. Information can be found here . New: Support for Android Architecture Components! ( #71 ) With the beta release of architecture components, they are now supported in the autodispose-android-archcomponents artifact. Observable ( 1 ) . to ( AutoDispose . with ( AndroidLifecycleScopeProvider . from ( this )). forObservable ()) . subscribe (); Where this could be anything that implements LifecycleOwner or extends Lifecycle . compile 'com.uber.autodispose:autodispose-android-archcomponents:x.y.z' Thanks to @yigit , @jaychang0917 , and @lsvijay for their help and contributions on this! New: Delegate Observer retrieval ( #89 ) Every automatically disposing observer implements one of the corresponding AutoDisposing____Observer interfaces in the com.uber.autodispose.observers package. They are considered read-only public API, with the intention that you can look for them in the RxJava plugin system (such as an onSubscribe hook). This extends their functionality to expose a new experimental API called delegateObserver() . This allows you to access the underlying observer that this is automatically disposing. The reason for this is that there may be conditions where you want to handle functionality depending on information from that Observer. As of RxJava 2.1.4, one such case could be to read information from a LambdaConsumerIntrospection ( relevant PR ). In the future, this will likely be narrowed to return a @Nullable lambdaConsumerIntrospection() , but we\u2019re open to feedback if others think this should remain the high level Observer type. Thanks to @mswysocki for his contribution on this! New: JSR 305 Nullability Annotations ( #79 ) AutoDispose packages now leverage JSR 305 annotations to indicate nullability. By default, all methods and parameters are non-null by default. This uses the spin-off javax-extras artifact for method nullability support, and is only a compileOnly dependency (so it should show up) for tooling but is not packaged as a compile dependency. Further reading: https://medium.com/square-corner-blog/non-null-is-the-default-58ffc0bb9111 New: Sample android app! ( #97 ) For a long time, AutoDispose relied on tests and the README to be demonstrations of API use. It\u2019s become clear that this is not enough information though, so we\u2019ve added a full sample app (borrowing heavily from RxLifecycle/Conductor\u2019s) to better illustrate API usage and runtime behavior. We\u2019ll continue to iterate on this over time. Improved: EndConsumerHelper ( #77 ) AutoDispose uses the same disposal-helper utilities as RxJava. This updates to RxJava\u2019s new EndConsumerHelper , which should hopefully help produce more helpful error messages in disposal error conditions. Other Updated various dependencies: Android Arch Components: 1.0.0-beta1 Android Support Library: 26.1.0 (to match arch components) Kotlin: 1.1.50 As always, we welcome any and all discussions/feedback/PRs! We\u2019re marching toward a 1.0 release Real Soon Now, so now is the time. There are a few outstanding discussion issues in the issue tracker about 1.0 final design decisions.","title":"Version 0.3.0"},{"location":"changelog/#version-020","text":"2017-05-08 New: Kotlin artifact! (#47) This adds autoDisposeWith() extensions to RxJava types. myObservable . doWhatever () . autoDisposeWith ( this ) . subscribe () New: Plugin system! (#57) Modeled after RxJava\u2019s plugins, this allows you to customize the behavior of AutoDispose with lifecycle boundary checks. AutoDisposePlugins . setOutsideLifecycleHandler ( t -> { // Swallow the exception, or rethrow it, or throw your own! }) A good use case of this is, say, just silently disposing/logging observers outside of lifecycle exceptions in production but crashing on debug. New: Test helpers! (#48 #49) Two helpers were added to simulate conditions in testing. - TestLifecycleScopeProvider - This has two corresponding lifecycle methods: start() and stop() - TestScopeProvider - Has just one method - emit() . For testing with just the Maybe<?> scope, we recommend using RxJava\u2019s built-in MaybeSubject . Fix : Fixed a race condition where upstream wouldn\u2019t be disposed if the lifecycle emitted or error\u2019d synchronously (i.e. was already terminated). (#57) Fix : Add missing @CheckReturnValue annotations to subscribeWith methods. (#53) Other tidbits: - Removed @NonNull annotations. Everything is @NonNull by default, and only elements annotated with @Nullable are not. - Use of the new java-library plugin for gradle (#64). The RxJava dependencies are marked as api . - Error prone has been integrated. Currently the annotations are just marked as compileOnly , but if a need arises/community wants them - we can compile them in a future version.","title":"Version 0.2.0"},{"location":"changelog/#version-010","text":"2017-03-13 Initial release","title":"Version 0.1.0"},{"location":"code-of-conduct/","text":"Contributor Covenant Code of Conduct \u00b6 Our Pledge \u00b6 In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation. Our Standards \u00b6 Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others\u2019 private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Our Responsibilities \u00b6 Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope \u00b6 This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. Enforcement \u00b6 Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at mobile-open-source@uber.com . The project team will review and investigate all complaints, and will respond in a way that it deems appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project\u2019s leadership. Attribution \u00b6 This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at http://contributor-covenant.org/version/\u00bc","title":"Code of Conduct"},{"location":"code-of-conduct/#contributor-covenant-code-of-conduct","text":"","title":"Contributor Covenant Code of Conduct"},{"location":"code-of-conduct/#our-pledge","text":"In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.","title":"Our Pledge"},{"location":"code-of-conduct/#our-standards","text":"Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others\u2019 private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"code-of-conduct/#our-responsibilities","text":"Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.","title":"Our Responsibilities"},{"location":"code-of-conduct/#scope","text":"This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.","title":"Scope"},{"location":"code-of-conduct/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at mobile-open-source@uber.com . The project team will review and investigate all complaints, and will respond in a way that it deems appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project\u2019s leadership.","title":"Enforcement"},{"location":"code-of-conduct/#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at http://contributor-covenant.org/version/\u00bc","title":"Attribution"},{"location":"contributing/","text":"Contributing to AutoDispose \u00b6 The Uber team welcomes contributions of all kinds, from simple bug reports through documentation, test cases, bugfixes, and features. Workflow \u00b6 We love GitHub issues! For small feature requests, an issue first proposing it for discussion or demo implementation in a PR suffice. For big features, please open an issue so that we can agree on the direction, and hopefully avoid investing a lot of time on a feature that might need reworking. Small pull requests for things like typos, bugfixes, etc are always welcome. Code style \u00b6 This project uses ktlint and GJF , provided via the spotless gradle plugin. If you find that one of your pull reviews does not pass the CI server check due to a code style conflict, you can easily fix it by running: ./gradlew spotlessApply. Generally speaking - we use vanilla ktlint + 2space indents, and vanilla GJF. You can integrate both of these in IntelliJ code style via either GJF\u2019s official plugin or applying code style from Jetbrains\u2019 official style. No star imports please! DOs and DON\u2019Ts \u00b6 DO follow our coding style DO include tests when adding new features. When fixing bugs, start with adding a test that highlights how the current behavior is broken. DO keep the discussions focused. When a new or related topic comes up it\u2019s often better to create new issue than to side track the discussion. DO run all Gradle verification tasks ( ./gradlew check ) before submitting a pull request DON\u2019T submit PRs that alter licensing related files or headers. If you believe there\u2019s a problem with them, file an issue and we\u2019ll be happy to discuss it.","title":"Contributing"},{"location":"contributing/#contributing-to-autodispose","text":"The Uber team welcomes contributions of all kinds, from simple bug reports through documentation, test cases, bugfixes, and features.","title":"Contributing to AutoDispose"},{"location":"contributing/#workflow","text":"We love GitHub issues! For small feature requests, an issue first proposing it for discussion or demo implementation in a PR suffice. For big features, please open an issue so that we can agree on the direction, and hopefully avoid investing a lot of time on a feature that might need reworking. Small pull requests for things like typos, bugfixes, etc are always welcome.","title":"Workflow"},{"location":"contributing/#code-style","text":"This project uses ktlint and GJF , provided via the spotless gradle plugin. If you find that one of your pull reviews does not pass the CI server check due to a code style conflict, you can easily fix it by running: ./gradlew spotlessApply. Generally speaking - we use vanilla ktlint + 2space indents, and vanilla GJF. You can integrate both of these in IntelliJ code style via either GJF\u2019s official plugin or applying code style from Jetbrains\u2019 official style. No star imports please!","title":"Code style"},{"location":"contributing/#dos-and-donts","text":"DO follow our coding style DO include tests when adding new features. When fixing bugs, start with adding a test that highlights how the current behavior is broken. DO keep the discussions focused. When a new or related topic comes up it\u2019s often better to create new issue than to side track the discussion. DO run all Gradle verification tasks ( ./gradlew check ) before submitting a pull request DON\u2019T submit PRs that alter licensing related files or headers. If you believe there\u2019s a problem with them, file an issue and we\u2019ll be happy to discuss it.","title":"DOs and DON'Ts"},{"location":"error-prone/","text":"AutoDispose is an Error-Prone check to detect missing AutoDispose scope within defined scoped elements. Installation \u00b6 Below are sample configurations which pull in both the AutoDispose Error-Prone checker. Gradle \u00b6 Java \u00b6 plugins { id \"java-library\" // Or whatever other java plugin you're using id \"net.ltgt.errorprone\" version \"0.6\" } dependencies { errorprone \"com.uber.autodispose:autodispose-error-prone:x.y.z\" // where x.y.z is the latest version. errorprone \"com.google.errorprone:error_prone_core:2.3.2\" // Or whatever the latest version is } tasks.withType(JavaCompile).configureEach { // Only if you want to support custom types with scopes // Below is a sample configuration which includes Conductor def classesWithScope = [ \"com.bluelinelabs.conductor.Controller\" ] options.errorprone { check(\"AutoDispose\", CheckSeverity.ERROR) option(\"AutoDispose:TypesWithScope\", classesWithScope.join(\",\")) option(\"UAutoDispose:Lenient\", \"true\") } } Android \u00b6 plugins { id \"net.ltgt.errorprone\" version \"0.0.13\" } dependencies { errorprone \"com.uber.autodispose:autodispose-error-prone-checker:x.y.z\" // where x.y.z is the latest version. errorprone \"com.google.errorprone:error_prone_core:2.3.2\" // Or whatever the latest version is } // Must go in afterEvaluate afterEvaluate { tasks.withType(JavaCompile).configureEach { // Only if you want to support custom types with scopes // Below is a sample configuration which includes Conductor def classesWithScope = [ \"com.bluelinelabs.conductor.Controller\" ] options.errorprone { check(\"AutoDispose\", CheckSeverity.ERROR) option(\"AutoDispose:TypesWithScope\", classesWithScope.join(\",\")) option(\"AutoDispose:Lenient\", \"true\") } } } Maven \u00b6 <build> <plugins> <plugin> <groupId> org.apache.maven.plugins </groupId> <artifactId> maven-compiler-plugin </artifactId> <version> 3.5 </version> <configuration> <compilerId> javac-with-errorprone </compilerId> <forceJavacCompilerUse> true </forceJavacCompilerUse> <source> 1.8 </source> <target> 1.8 </target> <showWarnings> true </showWarnings> <annotationProcessorPaths> <path> <groupId> com.uber.autodispose </groupId> <artifactId> autodispose-error-prone </artifactId> <version> x.y.z </version> </path> </annotationProcessorPaths> <compilerArgs> <!-- Only if you want to support custom configuration Below is a sample configuration which includes Conductor --> <arg> --XepOpt:AutoDispose:TypesWithScope=com.bluelinelabs.conductor.Controller </arg> <arg> --XepOpt:AutoDispose:Lenient=true </arg> </compilerArgs> </configuration> <dependencies> <dependency> <groupId> org.codehaus.plexus </groupId> <artifactId> plexus-compiler-javac-errorprone </artifactId> <version> 2.8 </version> </dependency> <!-- override plexus-compiler-javac-errorprone's dependency on Error Prone with the latest version --> <dependency> <groupId> com.google.errorprone </groupId> <artifactId> error_prone_core </artifactId> <version> 2.3.2 </version> </dependency> </dependencies> </plugin> </build> Report example \u00b6 The following code snippet: public class ComponentWithLifecycle extends Activity { public void observeOnSomething () { Observable . interval ( 1 , TimeUnit . SECONDS ) . subscribe ( new Consumer < Long > () { @Override public void accept ( Long interval ) throws Exception { System . out . println ( interval ); } }); } } would produce the following error: ./gradlew build error: [AutoDispose] Missing Disposable handling: Apply AutoDispose or cache the Disposable instance manually and enable lenient mode. .subscribe(new Consumer<Long>() { ^ (see https://github.com/uber/AutoDispose/wiki/Error-Prone-Checker) Would lead to this error at compile-time. Configuration \u00b6 Scopes \u00b6 By default the checker is applied to AutoDispose interfaces and standard Android components with lifecycles: 1. Activity 2. Fragment 3. Support Fragment 4. LifecycleScopeProvider 5. ScopeProvider 6. LifecycleOwner This can be configured by Error-Prone\u2019s command line flags . The following flag is supported and takes input in a form of comma separated list of fully qualified class names of classes with scopes: -XepOpt:AutoDispose:TypesWithScope=com.bluelinelabs.conductor.Controller,android.app.Activity This flag adds the provided custom scopes to the default scopes mentioned above. Overriding Scopes \u00b6 If you only want the error prone check to run on your custom scopes and not the default ones, you can simply override the default scopes by adding the OverrideScopes flag like so: -XepOpt:AutoDispose:OverrideScopes=true Lenient \u00b6 Lenient is a mode to ask the checker to be lenient when capturing returned Disposable types. What this means is that if an rx subscribe method is called and its returned Disposable is captured, AutoDispose this code is manually managing the subscription and show ignore it. The same applies for capturing the returned value of subscribeWith if the input type implements Disposable . This can be configured by Error-Prone\u2019s command line flags . The following flag is supported and takes input in a form of a boolean true or false : -XepOpt:AutoDispose:Lenient=true The default value of this is false . Examples // This is allowed in lenient mode Disposable d = Observable . just ( 1 ). subscribe (); // This is allowed in lenient mode, because the subscribeWith arg type is Disposable DisposableObserver < Integer > do = Observable . just ( 1 ). subscribeWith ( new DisposableObserver ...) // This is not allowed in lenient mode, because the subscribeWith arg type is not Disposable Observer < Integer > do = Observable . just ( 1 ). subscribeWith ( new Observer ...) // This is not allowed in lenient mode, because the return value is not captured Observable . just ( 1 ). subscribe (); // This is not allowed in lenient mode, because that subscribe() overload just returns void Observable . just ( 1 ). subscribe ( new Observer ...)","title":"Error Prone"},{"location":"error-prone/#installation","text":"Below are sample configurations which pull in both the AutoDispose Error-Prone checker.","title":"Installation"},{"location":"error-prone/#gradle","text":"","title":"Gradle"},{"location":"error-prone/#java","text":"plugins { id \"java-library\" // Or whatever other java plugin you're using id \"net.ltgt.errorprone\" version \"0.6\" } dependencies { errorprone \"com.uber.autodispose:autodispose-error-prone:x.y.z\" // where x.y.z is the latest version. errorprone \"com.google.errorprone:error_prone_core:2.3.2\" // Or whatever the latest version is } tasks.withType(JavaCompile).configureEach { // Only if you want to support custom types with scopes // Below is a sample configuration which includes Conductor def classesWithScope = [ \"com.bluelinelabs.conductor.Controller\" ] options.errorprone { check(\"AutoDispose\", CheckSeverity.ERROR) option(\"AutoDispose:TypesWithScope\", classesWithScope.join(\",\")) option(\"UAutoDispose:Lenient\", \"true\") } }","title":"Java"},{"location":"error-prone/#android","text":"plugins { id \"net.ltgt.errorprone\" version \"0.0.13\" } dependencies { errorprone \"com.uber.autodispose:autodispose-error-prone-checker:x.y.z\" // where x.y.z is the latest version. errorprone \"com.google.errorprone:error_prone_core:2.3.2\" // Or whatever the latest version is } // Must go in afterEvaluate afterEvaluate { tasks.withType(JavaCompile).configureEach { // Only if you want to support custom types with scopes // Below is a sample configuration which includes Conductor def classesWithScope = [ \"com.bluelinelabs.conductor.Controller\" ] options.errorprone { check(\"AutoDispose\", CheckSeverity.ERROR) option(\"AutoDispose:TypesWithScope\", classesWithScope.join(\",\")) option(\"AutoDispose:Lenient\", \"true\") } } }","title":"Android"},{"location":"error-prone/#maven","text":"<build> <plugins> <plugin> <groupId> org.apache.maven.plugins </groupId> <artifactId> maven-compiler-plugin </artifactId> <version> 3.5 </version> <configuration> <compilerId> javac-with-errorprone </compilerId> <forceJavacCompilerUse> true </forceJavacCompilerUse> <source> 1.8 </source> <target> 1.8 </target> <showWarnings> true </showWarnings> <annotationProcessorPaths> <path> <groupId> com.uber.autodispose </groupId> <artifactId> autodispose-error-prone </artifactId> <version> x.y.z </version> </path> </annotationProcessorPaths> <compilerArgs> <!-- Only if you want to support custom configuration Below is a sample configuration which includes Conductor --> <arg> --XepOpt:AutoDispose:TypesWithScope=com.bluelinelabs.conductor.Controller </arg> <arg> --XepOpt:AutoDispose:Lenient=true </arg> </compilerArgs> </configuration> <dependencies> <dependency> <groupId> org.codehaus.plexus </groupId> <artifactId> plexus-compiler-javac-errorprone </artifactId> <version> 2.8 </version> </dependency> <!-- override plexus-compiler-javac-errorprone's dependency on Error Prone with the latest version --> <dependency> <groupId> com.google.errorprone </groupId> <artifactId> error_prone_core </artifactId> <version> 2.3.2 </version> </dependency> </dependencies> </plugin> </build>","title":"Maven"},{"location":"error-prone/#report-example","text":"The following code snippet: public class ComponentWithLifecycle extends Activity { public void observeOnSomething () { Observable . interval ( 1 , TimeUnit . SECONDS ) . subscribe ( new Consumer < Long > () { @Override public void accept ( Long interval ) throws Exception { System . out . println ( interval ); } }); } } would produce the following error: ./gradlew build error: [AutoDispose] Missing Disposable handling: Apply AutoDispose or cache the Disposable instance manually and enable lenient mode. .subscribe(new Consumer<Long>() { ^ (see https://github.com/uber/AutoDispose/wiki/Error-Prone-Checker) Would lead to this error at compile-time.","title":"Report example"},{"location":"error-prone/#configuration","text":"","title":"Configuration"},{"location":"error-prone/#scopes","text":"By default the checker is applied to AutoDispose interfaces and standard Android components with lifecycles: 1. Activity 2. Fragment 3. Support Fragment 4. LifecycleScopeProvider 5. ScopeProvider 6. LifecycleOwner This can be configured by Error-Prone\u2019s command line flags . The following flag is supported and takes input in a form of comma separated list of fully qualified class names of classes with scopes: -XepOpt:AutoDispose:TypesWithScope=com.bluelinelabs.conductor.Controller,android.app.Activity This flag adds the provided custom scopes to the default scopes mentioned above.","title":"Scopes"},{"location":"error-prone/#overriding-scopes","text":"If you only want the error prone check to run on your custom scopes and not the default ones, you can simply override the default scopes by adding the OverrideScopes flag like so: -XepOpt:AutoDispose:OverrideScopes=true","title":"Overriding Scopes"},{"location":"error-prone/#lenient","text":"Lenient is a mode to ask the checker to be lenient when capturing returned Disposable types. What this means is that if an rx subscribe method is called and its returned Disposable is captured, AutoDispose this code is manually managing the subscription and show ignore it. The same applies for capturing the returned value of subscribeWith if the input type implements Disposable . This can be configured by Error-Prone\u2019s command line flags . The following flag is supported and takes input in a form of a boolean true or false : -XepOpt:AutoDispose:Lenient=true The default value of this is false . Examples // This is allowed in lenient mode Disposable d = Observable . just ( 1 ). subscribe (); // This is allowed in lenient mode, because the subscribeWith arg type is Disposable DisposableObserver < Integer > do = Observable . just ( 1 ). subscribeWith ( new DisposableObserver ...) // This is not allowed in lenient mode, because the subscribeWith arg type is not Disposable Observer < Integer > do = Observable . just ( 1 ). subscribeWith ( new Observer ...) // This is not allowed in lenient mode, because the return value is not captured Observable . just ( 1 ). subscribe (); // This is not allowed in lenient mode, because that subscribe() overload just returns void Observable . just ( 1 ). subscribe ( new Observer ...)","title":"Lenient"},{"location":"lint-check/","text":"AutoDisposeDetector is a lint check to detect missing AutoDispose scope within defined scoped elements. Installation \u00b6 For Android Java/Kotlin projects, no configuration is required as the AutoDispose lint check is run by default with the existing lint checks. For pure JVM projects, apply the com.android.lint plugin and add the lint dependency to the lintChecks configuration. plugins { id \"org.jetbrains.kotlin.jvm\" id \"com.android.lint\" } dependencies { lintChecks \"com.uber.autodispose2:autodispose-lint:<version>\" } Report example \u00b6 The following code snippet: class ComponentWithLifecycle : Activity { fun observeOnSomething () { Observable . interval ( 1 , TimeUnit . SECONDS ) . subscribe { println ( it ) } } } will produce the following error at compile-time: ./gradlew build src/com/sample/app/ComponentWithLifecycle.kt:5: Error: Missing Disposable handling: Apply AutoDispose or cache the Disposable instance manually and enable lenient mode. [AutoDispose] .subscribe { println(it) } ~~~~~~~~~~~~~~~~~~~~~~~~~~ 1 errors, 0 warnings Configuration \u00b6 Scopes \u00b6 By default, the lint check is applied to AutoDispose interfaces and standard Android components with lifecycles: 1. Activity 2. Fragment 3. Support Fragment 4. ScopeProvider (which implicitly includes LifecycleScopeProvider ) 5. LifecycleOwner You can add your own custom scopes that you want the lint check applied to. In your app-level gradle.properties file, add the fully qualified name of your custom classes as comma-separated-values like so: autodispose . typesWithScope = com . bluelinelabs . conductor . Controller , com . sample . app . BasePresenter The types supplied are then added to the default types listed above. Overriding Scopes \u00b6 If you only want the lint check to run on your custom scopes and not the default ones, you can simply override the default scopes by adding this in your app-level gradle.properties file: autodispose . overrideScopes = true Lenient \u00b6 Lenient is a mode to ask the checker to be lenient when capturing returned Disposable types. What this means is that if an rx subscribe method is called and its returned Disposable is captured, AutoDispose this code is manually managing the subscription and show ignore it. The same applies for capturing the returned value of subscribeWith if the input type implements Disposable. This can be configured by adding the following flag to the app-level gradle.properties file. autodispose . lenient = true The default value of this is false . Kotlin Extension \u00b6 By default, subscribe and subscribeWith methods are checked. To support other subscribe methods such as subscribeBy in RxKotlin, you can add your own subscribe extensions. In your app-level gradle.properties files, add kotlin extension functions in format of {full package name for extension's scope}#{functionName} and comma-separated-values like so: autodispose.kotlinExtensionFunctions = \"io.reactivex.rxjava3.kotlin.subscribers#subscribeBy,com.sample.app.SubscribeExt#subscribe2\" Examples \u00b6 // This is allowed in lenient mode Disposable d = Observable . just ( 1 ). subscribe (); // This is allowed in lenient mode, because the subscribeWith arg type is Disposable DisposableObserver < Integer > do = Observable . just ( 1 ). subscribeWith ( new DisposableObserver ...) // This is not allowed in lenient mode, because the subscribeWith arg type is not Disposable Observer < Integer > do = Observable . just ( 1 ). subscribeWith ( new Observer ...) // This is not allowed in lenient mode, because the return value is not captured Observable . just ( 1 ). subscribe (); // This is not allowed in lenient mode, because that subscribe() overload just returns void Observable . just ( 1 ). subscribe ( new Observer ...) // This is not allowed when kotlin extension functions option is used Observable . just ( 1 ). subscribeBy { }","title":"Lint Check"},{"location":"lint-check/#installation","text":"For Android Java/Kotlin projects, no configuration is required as the AutoDispose lint check is run by default with the existing lint checks. For pure JVM projects, apply the com.android.lint plugin and add the lint dependency to the lintChecks configuration. plugins { id \"org.jetbrains.kotlin.jvm\" id \"com.android.lint\" } dependencies { lintChecks \"com.uber.autodispose2:autodispose-lint:<version>\" }","title":"Installation"},{"location":"lint-check/#report-example","text":"The following code snippet: class ComponentWithLifecycle : Activity { fun observeOnSomething () { Observable . interval ( 1 , TimeUnit . SECONDS ) . subscribe { println ( it ) } } } will produce the following error at compile-time: ./gradlew build src/com/sample/app/ComponentWithLifecycle.kt:5: Error: Missing Disposable handling: Apply AutoDispose or cache the Disposable instance manually and enable lenient mode. [AutoDispose] .subscribe { println(it) } ~~~~~~~~~~~~~~~~~~~~~~~~~~ 1 errors, 0 warnings","title":"Report example"},{"location":"lint-check/#configuration","text":"","title":"Configuration"},{"location":"lint-check/#scopes","text":"By default, the lint check is applied to AutoDispose interfaces and standard Android components with lifecycles: 1. Activity 2. Fragment 3. Support Fragment 4. ScopeProvider (which implicitly includes LifecycleScopeProvider ) 5. LifecycleOwner You can add your own custom scopes that you want the lint check applied to. In your app-level gradle.properties file, add the fully qualified name of your custom classes as comma-separated-values like so: autodispose . typesWithScope = com . bluelinelabs . conductor . Controller , com . sample . app . BasePresenter The types supplied are then added to the default types listed above.","title":"Scopes"},{"location":"lint-check/#overriding-scopes","text":"If you only want the lint check to run on your custom scopes and not the default ones, you can simply override the default scopes by adding this in your app-level gradle.properties file: autodispose . overrideScopes = true","title":"Overriding Scopes"},{"location":"lint-check/#lenient","text":"Lenient is a mode to ask the checker to be lenient when capturing returned Disposable types. What this means is that if an rx subscribe method is called and its returned Disposable is captured, AutoDispose this code is manually managing the subscription and show ignore it. The same applies for capturing the returned value of subscribeWith if the input type implements Disposable. This can be configured by adding the following flag to the app-level gradle.properties file. autodispose . lenient = true The default value of this is false .","title":"Lenient"},{"location":"lint-check/#kotlin-extension","text":"By default, subscribe and subscribeWith methods are checked. To support other subscribe methods such as subscribeBy in RxKotlin, you can add your own subscribe extensions. In your app-level gradle.properties files, add kotlin extension functions in format of {full package name for extension's scope}#{functionName} and comma-separated-values like so: autodispose.kotlinExtensionFunctions = \"io.reactivex.rxjava3.kotlin.subscribers#subscribeBy,com.sample.app.SubscribeExt#subscribe2\"","title":"Kotlin Extension"},{"location":"lint-check/#examples","text":"// This is allowed in lenient mode Disposable d = Observable . just ( 1 ). subscribe (); // This is allowed in lenient mode, because the subscribeWith arg type is Disposable DisposableObserver < Integer > do = Observable . just ( 1 ). subscribeWith ( new DisposableObserver ...) // This is not allowed in lenient mode, because the subscribeWith arg type is not Disposable Observer < Integer > do = Observable . just ( 1 ). subscribeWith ( new Observer ...) // This is not allowed in lenient mode, because the return value is not captured Observable . just ( 1 ). subscribe (); // This is not allowed in lenient mode, because that subscribe() overload just returns void Observable . just ( 1 ). subscribe ( new Observer ...) // This is not allowed when kotlin extension functions option is used Observable . just ( 1 ). subscribeBy { }","title":"Examples"},{"location":"migrating-020-030/","text":"0.3.0 switched the API to the new static factories in AutoDispose.java . To migrate, you can leverage IntelliJ\u2019s structural replace. Below is an exhaustive list. I suspect this could be whittled down to Completable replacement and java \u215e generic templates, but my script text fu isn\u2019t good enough (contributions welcome!). Notes for structural replace. If using Java 8, replace <$Type$> with <> and remove <$Type> from the replacement template. Would be ideal to combine these into one smart replace but the tooling is a little rough to debug. Flowable \u00b6 Java 8 / Object streams \u00b6 Search template $Stream$.to(new com.uber.autodispose.FlowableScoper<>($Scope$)) Replacement template $Stream$.to(com.uber.autodispose.AutoDispose.with($Scope$).forFlowable()) Java 7 regular types \u00b6 Search template $Stream$.to(new com.uber.autodispose.FlowableScoper<$Type$>($Scope$)) Replacement template $Stream$.to(com.uber.autodispose.AutoDispose.with($Scope$).<$Type$>forFlowable()) Observable \u00b6 Java 8 / Object streams \u00b6 Search template $Stream$.to(new com.uber.autodispose.ObservableScoper<>($Scope$)) Replacement template $Stream$.to(com.uber.autodispose.AutoDispose.with($Scope$).forObservable()) Java 7 regular types \u00b6 Search template $Stream$.to(new com.uber.autodispose.ObservableScoper<$Type$>($Scope$)) Replacement template $Stream$.to(com.uber.autodispose.AutoDispose.with($Scope$).<$Type$>forObservable()) Maybe \u00b6 Java 8 / Object streams \u00b6 Search template $Stream$.to(new com.uber.autodispose.MaybeScoper<>($Scope$)) Replacement template $Stream$.to(com.uber.autodispose.AutoDispose.with($Scope$).forMaybe()) Java 7 regular types \u00b6 Search template $Stream$.to(new com.uber.autodispose.MaybeScoper<$Type$>($Scope$)) Replacement template $Stream$.to(com.uber.autodispose.AutoDispose.with($Scope$).<$Type$>forMaybe()) Single \u00b6 Java 8 / Object streams \u00b6 Search template $Stream$.to(new com.uber.autodispose.SingleScoper<>($Scope$)) Replacement template $Stream$.to(com.uber.autodispose.AutoDispose.with($Scope$).forSingle()) Java 7 regular types \u00b6 Search template $Stream$.to(new com.uber.autodispose.SingleScoper<$Type$>($Scope$)) Replacement template $Stream$.to(com.uber.autodispose.AutoDispose.with($Scope$).<$Type$>forSingle()) Completable \u00b6 Search template $Stream$.to(new com.uber.autodispose.CompletableScoper($Scope$)) Replacement template $Stream$.to(com.uber.autodispose.AutoDispose.with($Scope$).forCompletable())","title":"Migrating from 0.2.0 to 0.3.0"},{"location":"migrating-020-030/#flowable","text":"","title":"Flowable"},{"location":"migrating-020-030/#java-8-object-streams","text":"Search template $Stream$.to(new com.uber.autodispose.FlowableScoper<>($Scope$)) Replacement template $Stream$.to(com.uber.autodispose.AutoDispose.with($Scope$).forFlowable())","title":"Java 8 / Object streams"},{"location":"migrating-020-030/#java-7-regular-types","text":"Search template $Stream$.to(new com.uber.autodispose.FlowableScoper<$Type$>($Scope$)) Replacement template $Stream$.to(com.uber.autodispose.AutoDispose.with($Scope$).<$Type$>forFlowable())","title":"Java 7 regular types"},{"location":"migrating-020-030/#observable","text":"","title":"Observable"},{"location":"migrating-020-030/#java-8-object-streams_1","text":"Search template $Stream$.to(new com.uber.autodispose.ObservableScoper<>($Scope$)) Replacement template $Stream$.to(com.uber.autodispose.AutoDispose.with($Scope$).forObservable())","title":"Java 8 / Object streams"},{"location":"migrating-020-030/#java-7-regular-types_1","text":"Search template $Stream$.to(new com.uber.autodispose.ObservableScoper<$Type$>($Scope$)) Replacement template $Stream$.to(com.uber.autodispose.AutoDispose.with($Scope$).<$Type$>forObservable())","title":"Java 7 regular types"},{"location":"migrating-020-030/#maybe","text":"","title":"Maybe"},{"location":"migrating-020-030/#java-8-object-streams_2","text":"Search template $Stream$.to(new com.uber.autodispose.MaybeScoper<>($Scope$)) Replacement template $Stream$.to(com.uber.autodispose.AutoDispose.with($Scope$).forMaybe())","title":"Java 8 / Object streams"},{"location":"migrating-020-030/#java-7-regular-types_2","text":"Search template $Stream$.to(new com.uber.autodispose.MaybeScoper<$Type$>($Scope$)) Replacement template $Stream$.to(com.uber.autodispose.AutoDispose.with($Scope$).<$Type$>forMaybe())","title":"Java 7 regular types"},{"location":"migrating-020-030/#single","text":"","title":"Single"},{"location":"migrating-020-030/#java-8-object-streams_3","text":"Search template $Stream$.to(new com.uber.autodispose.SingleScoper<>($Scope$)) Replacement template $Stream$.to(com.uber.autodispose.AutoDispose.with($Scope$).forSingle())","title":"Java 8 / Object streams"},{"location":"migrating-020-030/#java-7-regular-types_3","text":"Search template $Stream$.to(new com.uber.autodispose.SingleScoper<$Type$>($Scope$)) Replacement template $Stream$.to(com.uber.autodispose.AutoDispose.with($Scope$).<$Type$>forSingle())","title":"Java 7 regular types"},{"location":"migrating-020-030/#completable","text":"Search template $Stream$.to(new com.uber.autodispose.CompletableScoper($Scope$)) Replacement template $Stream$.to(com.uber.autodispose.AutoDispose.with($Scope$).forCompletable())","title":"Completable"},{"location":"migrating-040-050/","text":"0.5.0 switched the API to the new autoDisposable() static factories in AutoDispose.java . To migrate, you can leverage IntelliJ\u2019s structural replace. Below is an exhaustive list. I suspect this could be whittled down to Completable replacement and java \u215e generic templates, but my script text fu isn\u2019t good enough (contributions welcome!). Notes for structural replace. If using Java 8, replace <$Type$> with <> and remove <$Type> from the replacement template. Would be ideal to combine these into one smart replace but the tooling is a little rough to debug. Flowable \u00b6 Java 8 / Object streams \u00b6 Search template $Stream$.to(com.uber.autodispose.AutoDispose.with($Scope$).forFlowable()) Replacement template $Stream$.as(com.uber.autodispose.AutoDispose.autoDisposable($Scope$)) Java 7 regular types \u00b6 Search template $Stream$.to(com.uber.autodispose.AutoDispose.with($Scope$).<$Type$>forFlowable()) Replacement template $Stream$.as(com.uber.autodispose.AutoDispose.<$Type$>autoDisposable($Scope$)) Observable \u00b6 Java 8 / Object streams \u00b6 Search template $Stream$.to(com.uber.autodispose.AutoDispose.with($Scope$).forObservable()) Replacement template $Stream$.as(com.uber.autodispose.AutoDispose.autoDisposable($Scope$)) Java 7 regular types \u00b6 Search template $Stream$.to(com.uber.autodispose.AutoDispose.with($Scope$).<$Type$>forObservable()) Replacement template $Stream$.as(com.uber.autodispose.AutoDispose.<$Type$>autoDisposable($Scope$)) Maybe \u00b6 Java 8 / Object streams \u00b6 Search template $Stream$.to(com.uber.autodispose.AutoDispose.with($Scope$).forMaybe()) Replacement template $Stream$.as(com.uber.autodispose.AutoDispose.autoDisposable($Scope$)) Java 7 regular types \u00b6 Search template $Stream$.to(com.uber.autodispose.AutoDispose.with($Scope$).<$Type$>forMaybe()) Replacement template $Stream$.as(com.uber.autodispose.AutoDispose.<$Type$>autoDisposable($Scope$)) Single \u00b6 Java 8 / Object streams \u00b6 Search template $Stream$.to(com.uber.autodispose.AutoDispose.with($Scope$).forSingle()) Replacement template $Stream$.as(com.uber.autodispose.AutoDispose.autoDisposable($Scope$)) Java 7 regular types \u00b6 Search template $Stream$.to(com.uber.autodispose.AutoDispose.with($Scope$).<$Type$>forSingle()) Replacement template $Stream$.as(com.uber.autodispose.AutoDispose.<$Type$>autoDisposable($Scope$)) Completable \u00b6 Search template $Stream$.to(com.uber.autodispose.AutoDispose.with($Scope$).forCompletable()) Replacement template $Stream$.as(com.uber.autodispose.AutoDispose.autoDisposable($Scope$))","title":"Migrating from 0.4.0 to 0.5.0"},{"location":"migrating-040-050/#flowable","text":"","title":"Flowable"},{"location":"migrating-040-050/#java-8-object-streams","text":"Search template $Stream$.to(com.uber.autodispose.AutoDispose.with($Scope$).forFlowable()) Replacement template $Stream$.as(com.uber.autodispose.AutoDispose.autoDisposable($Scope$))","title":"Java 8 / Object streams"},{"location":"migrating-040-050/#java-7-regular-types","text":"Search template $Stream$.to(com.uber.autodispose.AutoDispose.with($Scope$).<$Type$>forFlowable()) Replacement template $Stream$.as(com.uber.autodispose.AutoDispose.<$Type$>autoDisposable($Scope$))","title":"Java 7 regular types"},{"location":"migrating-040-050/#observable","text":"","title":"Observable"},{"location":"migrating-040-050/#java-8-object-streams_1","text":"Search template $Stream$.to(com.uber.autodispose.AutoDispose.with($Scope$).forObservable()) Replacement template $Stream$.as(com.uber.autodispose.AutoDispose.autoDisposable($Scope$))","title":"Java 8 / Object streams"},{"location":"migrating-040-050/#java-7-regular-types_1","text":"Search template $Stream$.to(com.uber.autodispose.AutoDispose.with($Scope$).<$Type$>forObservable()) Replacement template $Stream$.as(com.uber.autodispose.AutoDispose.<$Type$>autoDisposable($Scope$))","title":"Java 7 regular types"},{"location":"migrating-040-050/#maybe","text":"","title":"Maybe"},{"location":"migrating-040-050/#java-8-object-streams_2","text":"Search template $Stream$.to(com.uber.autodispose.AutoDispose.with($Scope$).forMaybe()) Replacement template $Stream$.as(com.uber.autodispose.AutoDispose.autoDisposable($Scope$))","title":"Java 8 / Object streams"},{"location":"migrating-040-050/#java-7-regular-types_2","text":"Search template $Stream$.to(com.uber.autodispose.AutoDispose.with($Scope$).<$Type$>forMaybe()) Replacement template $Stream$.as(com.uber.autodispose.AutoDispose.<$Type$>autoDisposable($Scope$))","title":"Java 7 regular types"},{"location":"migrating-040-050/#single","text":"","title":"Single"},{"location":"migrating-040-050/#java-8-object-streams_3","text":"Search template $Stream$.to(com.uber.autodispose.AutoDispose.with($Scope$).forSingle()) Replacement template $Stream$.as(com.uber.autodispose.AutoDispose.autoDisposable($Scope$))","title":"Java 8 / Object streams"},{"location":"migrating-040-050/#java-7-regular-types_3","text":"Search template $Stream$.to(com.uber.autodispose.AutoDispose.with($Scope$).<$Type$>forSingle()) Replacement template $Stream$.as(com.uber.autodispose.AutoDispose.<$Type$>autoDisposable($Scope$))","title":"Java 7 regular types"},{"location":"migrating-040-050/#completable","text":"Search template $Stream$.to(com.uber.autodispose.AutoDispose.with($Scope$).forCompletable()) Replacement template $Stream$.as(com.uber.autodispose.AutoDispose.autoDisposable($Scope$))","title":"Completable"},{"location":"migrating-1x-2x/","text":"Migrating from AutoDispose 1.x to 2.x AutoDispose 2.x is built against RxJava 3.x and is binary-compatible with AutoDispose 1.x and RxJava 2.x. As such - it has a different package name and maven group ID. Packaging \u00b6 Maven Group ID Package Name 1.x com.uber.autodispose com.uber.autodispose 2.x com.uber.autodispose2 autodispose2 For any sub-packages, the above mapping should be used for those package prefix replacements as well. Changes \u00b6 All deprecated APIs in 1.x have been removed. This consisted exclusively of deprecated Kotlin autoDisposable extension functions that were deprecated in 1.4.0. The autodispose-android-archcomponents* artifacts have been renamed to to autodispose-androidx-lifecycle* to match the androidx-lifecycle library they correspond to. The lint and error prone checks have also been updated. We may look at consolidating these before 2.0 final is released if the community wants. At the time of writing, there is no RxLifecycle with RxJava 3 support yet, and as such there is no AutoDispose 2.x interop artifact for RxLifecycle. We can add this back if there\u2019s a new RxLifecycle release with RxJava 3.x support.","title":"Migrating from 1.x to 2.x"},{"location":"migrating-1x-2x/#packaging","text":"Maven Group ID Package Name 1.x com.uber.autodispose com.uber.autodispose 2.x com.uber.autodispose2 autodispose2 For any sub-packages, the above mapping should be used for those package prefix replacements as well.","title":"Packaging"},{"location":"migrating-1x-2x/#changes","text":"All deprecated APIs in 1.x have been removed. This consisted exclusively of deprecated Kotlin autoDisposable extension functions that were deprecated in 1.4.0. The autodispose-android-archcomponents* artifacts have been renamed to to autodispose-androidx-lifecycle* to match the androidx-lifecycle library they correspond to. The lint and error prone checks have also been updated. We may look at consolidating these before 2.0 final is released if the community wants. At the time of writing, there is no RxLifecycle with RxJava 3 support yet, and as such there is no AutoDispose 2.x interop artifact for RxLifecycle. We can add this back if there\u2019s a new RxLifecycle release with RxJava 3.x support.","title":"Changes"}]}